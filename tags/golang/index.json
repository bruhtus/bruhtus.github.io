[{"ref":"https://bruhtus.github.io/posts/golang-simple-query-composer-with-text-template-and-pgx/","title":"Golang Simple Query Composer With Text Template and Pgx","section":"posts","tags":["Golang"],"date":"2025.06.22","body":"For backend development at work, we just transitioned from Node.js to golang recently. We use pgx as our PostgreSQL driver. I\u0026rsquo;m not quite sure why we choose pgx as our PostgreSQL driver and not using ORM like gorm, so we won\u0026rsquo;t talk about that here. My principal is to adapt to the tech stack that the project use rather than forcing what i\u0026rsquo;m familiar with, so i don\u0026rsquo;t really mind.\nJust to be clear, as my workplace tech stack move to golang, that is also the first time i learn golang. So i have no prior experience with golang. In fact, by the time i write this post, i have less than one year experience with golang. You could say that i\u0026rsquo;m an inexperience golang developer that are trying things out and see if it works or not.\nWith that in mind, let\u0026rsquo;s moving into the topic. The problem i\u0026rsquo;m trying to solve here is the mess when we\u0026rsquo;re trying to compose an SQL query for pgx. Currently at work, when we compose the SQL query is that we use += to append new string into existing SQL query string.\nHere\u0026rsquo;s an example, let\u0026rsquo;s say we have a table articles with this columns:\nid author title content created_at updated_at And then we want to see how many articles each author has. With raw SQL query, we can do something like this:\nselectarticles.author,count(*)fromarticlesgroupbyarticles.author;If that\u0026rsquo;s all we need, then we can just write those SQL query as is in one string. Now the problem is, when we want to show only specific author. The raw SQL query would be something like this:\nselectarticles.author,count(*)fromarticleswherearticles.authorilike\u0026#39;%robertus%\u0026#39;groupbyarticles.author;Now we have two state, the one with all the authors and the one with specific author (searching feature). Currently at work, we compose those SQL query like this:\nvar args []interface{} query := ` select articles.author, count(*) from articles ` // Assume `Author` type is `string`. if filter.Author != \u0026#34;\u0026#34; { query += `where articles.author ilike $1` args = append(args, filter.Author) } query += fmt.Sprintf(`\\n%s`, \u0026#34;group by articles.author\u0026#34;) // Assume `db` type is `*pgxpool.Pool`. rows, err := db.Query(ctx, query, args...) defer rows.Close() ... I see at least 2 problems with the current query composer:\n What if we want to add another where filter to the query? What if we want to add where filter in a sub-query?  Now, what i proposed is that we use golang text/template package. I just recently found out about text/template package and i think we can use that as a simple SQL query composer.\nThe concept of using text/template package as SQL query composer is to use a placeholder inside the base query string.\nWith the previous scenario, we can use text/template package like this:\n// Use named arguments instead of positional arguments. var ( composedFilter []string queryBuilder = new(strings.Builder) // Using `strings` package.  conditionalTmpl = make(map[string]string) filterArgs = make(pgx.StrictNamedArgs) ) // The `-` at `{{end -}}` is to remove whitespace after the line. baseQuery := ` select articles.author, count(*) from articles {{if.Where}}{{.Where}}{{end-}}group by articles.author ` // Assume `Author` type is `string`. if filter.Author != \u0026#34;\u0026#34; { composedFilter = append(composedFilter, `articles.author ilike @author`) // Key `author` is the named argument `@author`, so make sure the name is  // the same.  filterArgs[\u0026#34;author\u0026#34;] = fmt.Sprintf(\u0026#34;%%%s%%\u0026#34;, filter.Author) } if len(composedFilter) \u0026gt; 0 { // This is a placeholder in `{{if .Where}}...` so make sure the name  // is the same.  conditionalTmpl[\u0026#34;Where\u0026#34;] = fmt.Sprintf( \u0026#34;where %s\\n\u0026#34;, strings.Join(composedFilter, ` AND `), ) } queryTmpl := template.Must(template.New(\u0026#34;baseQuery\u0026#34;).Parse(baseQuery)) if err != queryTmpl.Execute(queryBuilder, conditionalTmpl); err != nil { ... } query := queryBuilder.String() // Assume `db` type is `*pgxpool.Pool`. rows, err := db.Query(ctx, query, filterArgs) defer rows.Close() ... My concern with the text/template approach is that i don\u0026rsquo;t know the failure condition for template.Must(), so that might become a consideration when deciding to use this approach or not. It\u0026rsquo;s similar to when google/uuid package panic when using uuid.New(), you can check it out on this issue about the context .\nI already proposed this mechanism at work but i\u0026rsquo;m not sure if this mechanism will be used. So, i\u0026rsquo;m posting this in case someone need an inspiration for simple SQL query composer.\nAlright, that\u0026rsquo;s it. See you next time!\nReferences  Stackoverflow format go string .  "}]