[{"ref":"https://bruhtus.github.io/posts/remove-specific-line-in-vim/","title":"Remove Specific Line in Vim","section":"posts","tags":["Notes","Vim"],"date":"2022.09.03","body":"A Brief Intro In this post, we will talk about how to remove specific line in vim. We will be using this javascript snippet code as an example:\nconst app = require(\u0026#39;./jest-example\u0026#39;); const math = require(\u0026#39;./math\u0026#39;); describe(\u0026#39;app operation\u0026#39;, () =\u0026gt; { const multiplyMock = jest.spyOn(math, \u0026#39;multiply\u0026#39;); multiplyMock.mockReturnValue(\u0026#39;itu\u0026#39;); test(\u0026#39;call math.add()\u0026#39;, () =\u0026gt; { const add = jest.spyOn(math, \u0026#39;add\u0026#39;); add.mockImplementation(() =\u0026gt; \u0026#39;anu\u0026#39;); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(\u0026#39;anu\u0026#39;); add.mockRestore(); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(3); }); test(\u0026#39;call math.subtract()\u0026#39;, () =\u0026gt; { const subtract = jest.spyOn(math, \u0026#39;subtract\u0026#39;); subtract.mockImplementation(() =\u0026gt; \u0026#39;nganu\u0026#39;); console.log(app.doSubtract(1, 2)); expect(app.doSubtract(1, 2)).toBe(\u0026#39;nganu\u0026#39;); }); test(\u0026#39;call math.subtract() again\u0026#39;, () =\u0026gt; { console.log(app.doSubtract(1, 2)); }); test(\u0026#39;call math.multiply()\u0026#39;, () =\u0026gt; { console.log(app.doMultiply(1, 2)); }); }); And the goal is to remove line that has console.log() in it. Let\u0026rsquo;s get started!\nGlobal Command The first solution is that, we can use global command to delete the line that has console.log() like this:\n:g/console.log/dPlease keep in mind that the term delete in vim, means cut. So, rather than deleting the content, vim will put that into the unnamed register. For more info about unnamed register, we can check on :help registers.\nSo, if we didn\u0026rsquo;t want to clutter our unnamed register, we can use black hole register (yup, that\u0026rsquo;s a thing) which actually delete rather than cut like this:\n:g/console.log/d_On a side note, we don\u0026rsquo;t need to use / as the separator between command and pattern, we can use most characters except \\, \u0026quot;, or |. If we use vim9 script, we can use # as a separator either, so please keep that in mind. For more info, we can check on :help pattern-delimiter.\nIn other words, we can write the previous global command, like this:\n:g;console.log;d_The global command that we just gone through will delete all the console.log in current file. If we want to specify the area of console.log we want to delete, we can add range to global command.\nLet\u0026rsquo;s take a look at the snippet we are using:\nconst app = require(\u0026#39;./jest-example\u0026#39;); const math = require(\u0026#39;./math\u0026#39;); describe(\u0026#39;app operation\u0026#39;, () =\u0026gt; { const multiplyMock = jest.spyOn(math, \u0026#39;multiply\u0026#39;); multiplyMock.mockReturnValue(\u0026#39;itu\u0026#39;); test(\u0026#39;call math.add()\u0026#39;, () =\u0026gt; { const add = jest.spyOn(math, \u0026#39;add\u0026#39;); add.mockImplementation(() =\u0026gt; \u0026#39;anu\u0026#39;); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(\u0026#39;anu\u0026#39;); add.mockRestore(); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(3); }); test(\u0026#39;call math.subtract()\u0026#39;, () =\u0026gt; { const subtract = jest.spyOn(math, \u0026#39;subtract\u0026#39;); subtract.mockImplementation(() =\u0026gt; \u0026#39;nganu\u0026#39;); console.log(app.doSubtract(1, 2)); expect(app.doSubtract(1, 2)).toBe(\u0026#39;nganu\u0026#39;); }); test(\u0026#39;call math.subtract() again\u0026#39;, () =\u0026gt; { console.log(app.doSubtract(1, 2)); }); test(\u0026#39;call math.multiply()\u0026#39;, () =\u0026gt; { console.log(app.doMultiply(1, 2)); }); }); And let\u0026rsquo;s say that our cursor in the line test('call math.subtract()', () =\u0026gt; { and we want to delete the console.log in test('call math.add()', () =\u0026gt; { which is before the line we\u0026rsquo;re currently in.\nWith that in mind, we can do something like this:\n:?test?;/});/g;console.log;d_Here\u0026rsquo;s the breakdown of those command:\n ?test? will search word test on previous line. ; after ?test? is a special offset which tell vim that we will use another search command. For more info, we can check :help //;. /});/ will search after the result of previous search. g;console.log;d_ is a global command to delete console.log in the scope of previous search.  Substitute Command The downside of global command is that there\u0026rsquo;s no confirm option, so we might delete something we don\u0026rsquo;t want to. If we want a confirm option, we can use substitute command.\nIf we want to delete all the console.log in current file, we can do it like this:\n:%s;.*console.log.*\\n;;cHere\u0026rsquo;s the breakdown of those command:\n % symbol to tell vim that the range is the current file or all the line in the file. s is the abbreviation of substitute command. .*console.log.*\\n is the pattern that select the line that has console.log in it, which include the newline character at the end. ;; is basically telling vim to replace it with nothing. c is a confirm option.  We can also combine substitute command with global command, like this:\n:g;console.log;s;.*\\n;;cConclusion There\u0026rsquo;s a lot of possibility with global and substitute command and we won\u0026rsquo;t be able to cover all of those in one blog post. So, i will leave it to you to explore those possibility.\nYou might want to learn regular expression to enhance the global and substitute command experience.\nAlright, that\u0026rsquo;s it for this post. Thank you for reading!\n"},{"ref":"https://bruhtus.github.io/posts/vim-statusline/","title":"Guide to Make Your Own Vim/Neovim Statusline","section":"posts","tags":["Vim"],"date":"2021.08.20","body":" We don\u0026rsquo;t have to install vim plugin to get a statusline if we don\u0026rsquo;t want to.\n Introduction Hi everyone! In this post I will talk about making your custom statusline in vim. There are a lot of plugins out there that makes vim statusline way better and works out of the box.\n\u0026ldquo;Why would someone going through all the trouble while there\u0026rsquo;s a plugin for that?\u0026rdquo;, you might ask. Well, for me personally, having one less plugin is a good thing. I don\u0026rsquo;t really want to depend on the plugin for something simple such as statusline. If I can build it myself, then I will build it myself rather than using a plugin. Also, it save me a lot of time to figure out which plugin causes the issue if I have less plugin! Oh, another thing, some vim statusline plugin can slow down your startup time (I\u0026rsquo;m looking at you vim-airline) so be careful about that. Alright then, let\u0026rsquo;s get into it!\nRequirements Before we start, we need to prepare a few things:\n Vim/Neovim (we will use vim script or VimL in this post) set laststatus=2 (always display the statusline) Patience (don\u0026rsquo;t be scared when you see an error, calm down!)  If all is set, then let\u0026rsquo;s get started!\nDisable Old Statusline Before we move further, you need to disable or remove your old statusline plugin and the config. If you don\u0026rsquo;t want to remove your old statusline plugin config, you can commented out those line/config in your vimrc or init.vim.\nDifferent statusline for active and inactive window You can have different statusline for active and inactive window by using autocmd event. \u0026ldquo;What is autocmd?\u0026rdquo; you might ask, go take a look at :help autocmd for more info. To make it simple, autocmd is to automatically execute a command on certain event which you can check on :help autocmd-events for more info.\nSo, how can we have different statusline for active and inactive window? First, we need to make a function to define our active or inactive statusline component. You can create the function similar to this:\n\u0026#34; component for active windowfunction! StatuslineActive()\u0026#34; the component goes hereendfunction\u0026#34; component for inactive windowfunction! StatuslineInactive()\u0026#34; the component goes hereendfunction\u0026#34; load statusline using `autocmd` event with this functionfunction! StatuslineLoad(mode) if a:mode ==# \u0026#39;active\u0026#39;\u0026#34; to make it simple, %! is to evaluate the current changes in the window\u0026#34; it can be useful for evaluate current mode in statusline. For more info:\u0026#34; :help statusline. setlocal statusline=%!StatuslineActive() else setlocal statusline=%!StatuslineInactive() endifendfunctionand also the autocmd similar to this:\n\u0026#34; so that autocmd didn\u0026#39;t stack up and slow down vimaugroup statusline_startup autocmd!\u0026#34; for more info :help WinEnter and :help BufWinEnter autocmd WinEnter,BufWinEnter * call StatuslineLoad(\u0026#39;active\u0026#39;) autocmd WinLeave * call StatuslineLoad(\u0026#39;inactive\u0026#39;)augroup ENDNow we can compose our statusline component. We can take a look at :help statusline for supported items like for example f for relative path to the file in the buffer. You can choose whatever item you like in your statusline, and put it in the previous function similar to this:\nfunction! StatuslineActive()\u0026#34; if we want to add `f` items in our statusline let l:filename = \u0026#39;%f\u0026#39;\u0026#34; if we want to add \u0026#39;m\u0026#39; items in our statusline let l:mod = \u0026#39;%m\u0026#39;\u0026#34; the `.` is basically to ignore whitespace before and put it right after the previous component return l:filename.l:modendfunctionWhy we need to do that? well, I\u0026rsquo;ll explain it in next section\nCurrent Mode in Statusline If you want to put your current mode in your statusline, you can do it with a function similar to this:\nfunction! StatuslineMode() abort let l:currentmode={ \\ \u0026#39;n\u0026#39;: \u0026#39;N\u0026#39;, \\ \u0026#39;v\u0026#39;: \u0026#39;V\u0026#39;, \\ \u0026#39;V\u0026#39;: \u0026#39;VL\u0026#39;, \\ \u0026#39;^V\u0026#39;: \u0026#39;VB\u0026#39;, \\ \u0026#39;s\u0026#39;: \u0026#39;S\u0026#39;, \\ \u0026#39;S\u0026#39;: \u0026#39;SL\u0026#39;, \\ \u0026#39;^S\u0026#39;: \u0026#39;SB\u0026#39;, \\ \u0026#39;i\u0026#39;: \u0026#39;I\u0026#39;, \\ \u0026#39;R\u0026#39;: \u0026#39;R\u0026#39;, \\ \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \\ \u0026#39;t\u0026#39;: \u0026#39;T\u0026#39;} let l:modecurrent = mode()\u0026#34; use get() -\u0026gt; fails safely, since ^V doesn\u0026#39;t seem to register\u0026#34; 3rd arg is used when return of mode() == 0, which is case with ^V\u0026#34; thus, ^V fails -\u0026gt; returns 0 -\u0026gt; replaced with \u0026#39;VB\u0026#39; let l:modelist = toupper(get(l:currentmode, l:modecurrent, \u0026#39;VB\u0026#39;)) let l:current_status_mode = l:modelist return l:current_status_modeendfunctionand put it inside of your statusline function like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39;\u0026#34; `w:` is basically local variable to current window\u0026#34; and `l:` is basically local variable to function. For more info :help E121 let w:mode = \u0026#39;%{StatuslineMode()}\u0026#39; return w:mode.l:filename.l:modendfunctionNow, if we want to change the current mode background based on the current mode, we can do something like this:\n\u0026#34; define Normal mode color, Insert mode color, and so onhi NormalModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...hi InsertModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...function! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; %* is basically to restore highlight to StatusLine highlight group return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:modendfunctionGit Branch in Statusline If you install vim-fugitive plugin, then you can use fugitive#head() in your statusline like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; make sure it doesn\u0026#39;t throw an error if `vim-fugitive` is not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : \u0026#39;\u0026#39;}\u0026#34;\u0026#34; to separate left and right side let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionalternatively, you can use system() command to get the current git branch (for more info :help system()) like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; for more info :help E121 let g:gitbranchcmd = \u0026#34;git branch --show-current 2\u0026gt;/dev/null | tr -d \u0026#39;\\n\u0026#39;\u0026#34;\u0026#34; use system() if vim-fugitive not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : system(g:gitbranchcmd)}\u0026#34; let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionSame Statusline for active and inactive window Now, if we want our statusline to be the same whether in active or inactive window. We can make simplify it by only make one function and not using autocmd. It will look something like this:\nfunction! StatuslineComponent()\u0026#34; your component goes hereendfunctionset statusline=%!StatuslineComponent()and you can use some tips from previous section too!\nConclusion This guide is for do-it-yourself kind of people, so it\u0026rsquo;s only giving some pointer you can use to make your own statusline. I don\u0026rsquo;t want to tell you what to put in your statusline, it is your OWN statusline after all, so you need to know what you want in it. Also, I\u0026rsquo;m not a vim script expert so please forgive me if I miss something. If you have any question regarding this post, feel free to hit me up on twitter (@diawanchris)! See you later!\nReferences  Kade Killary blog post . Junegunn\u0026rsquo;s statusline .  "},{"ref":"https://bruhtus.github.io/posts/split-up-vimrc/","title":"Split Up Vimrc","section":"posts","tags":["Vim"],"date":"2021.03.22","body":" If you\u0026rsquo;re the type of person who like to place all your source code in one file, then this article is not for you. But, if you\u0026rsquo;re the type of person who like to split up your source code into a few sub-modules, then this article is for you.\n Skip-able Part When i look at my vimrc (vimrc is a vim config file for those who don\u0026rsquo;t know), i always feel confused where should i add new configuration for new plugin. I want to organize my vimrc so that it is easier to maintain and adding stuff, and that\u0026rsquo;s where the problem comes in.\nOvertime, when you keep adding configuration to vim, slowly your vimrc gonna become a huge mess and at some point it gonna feels cumbersome to access your vimrc. And that\u0026rsquo;s why i thought \u0026ldquo;can i split up my vimrc so that i don\u0026rsquo;t feel overwhelm every time i want to add new configuration or mapping to vim?\u0026rdquo; and it turns out i can.\nUpside and Downside Before we move on, you need to know the upside and downside for split up your vimrc that i\u0026rsquo;ve found. Here we go.\nUpside  Easier to manage, you can have a dedicated config file for every plugin you have Doesn\u0026rsquo;t overwhelm you with the piled up line of text, because it\u0026rsquo;s on separate file You can take a part of your config such as defaults setting and mappings, rather than a whole vim config (useful for accessing server with ssh)  Downside  You need to use grep or something similar if you want to check if the mapping already exist or not. If you didn\u0026rsquo;t split up your vimrc, you can just use vim built-in search function. You need to download a lot of file if you want to have full experience of your vim.  Split Up Vimrc If you still want to go on despite the downside, then it\u0026rsquo;s time to split up your vimrc.\nFirst thing first, you need to know that vim has runtime path which gonna be loaded everytime you start vim. And we can use the default runtime path to our advantage. For the full list, you can check here , but to make it simple, we\u0026rsquo;re only gonna use ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) directory. Every file in those directory get loaded every time you open vim, so you can add your config in those directory.\nFor example, you can move your defaults config such as set number relativenumber into file defaults.vim and place it in ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) and defaults config such as number and relativenumber gonna get loaded everytime you open vim.\nYou can also make config file for your plugin and give it the plugin name such as fugitive.vim and place it into ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin.\nThe Conclusion It\u0026rsquo;s quite easy to manage vim if you split up your vimrc, but it comes back to your personal preference. This article is just to remind vim user that they can split up their vimrc if they want to.\nReferences  Manage plugin in dark ages .  "}]