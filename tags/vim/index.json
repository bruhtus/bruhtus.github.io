[{"ref":"https://bruhtus.github.io/posts/vim-statusline/","title":"Guide to Make Your Own Vim/Neovim Statusline","section":"posts","tags":["Vim"],"date":"2021.08.20","body":" We don\u0026rsquo;t have to install vim plugin to get a statusline if we don\u0026rsquo;t want to.\n Introduction Hi everyone! In this post I will talk about making your custom statusline in vim. There are a lot of plugins out there that makes vim statusline way better and works out of the box.\n\u0026ldquo;Why would someone going through all the trouble while there\u0026rsquo;s a plugin for that?\u0026rdquo;, you might ask. Well, for me personally, having one less plugin is a good thing. I don\u0026rsquo;t really want to depend on the plugin for something simple such as statusline. If I can build it myself, then I will build it myself rather than using a plugin. Also, it save me a lot of time to figure out which plugin causes the issue if I have less plugin! Oh, another thing, some vim statusline plugin can slow down your startup time (I\u0026rsquo;m looking at you vim-airline) so be careful about that. Alright then, let\u0026rsquo;s get into it!\nRequirements Before we start, we need to prepare a few things:\n Vim/Neovim (we will use vim script or VimL in this post) set laststatus=2 (always display the statusline) Patience (don\u0026rsquo;t be scared when you see an error, calm down!)  If all is set, then let\u0026rsquo;s get started!\nDisable Old Statusline Before we move further, you need to disable or remove your old statusline plugin and the config. If you don\u0026rsquo;t want to remove your old statusline plugin config, you can commented out those line/config in your vimrc or init.vim.\nDifferent statusline for active and inactive window You can have different statusline for active and inactive window by using autocmd event. \u0026ldquo;What is autocmd?\u0026rdquo; you might ask, go take a look at :help autocmd for more info. To make it simple, autocmd is to automatically execute a command on certain event which you can check on :help autocmd-events for more info.\nSo, how can we have different statusline for active and inactive window? First, we need to make a function to define our active or inactive statusline component. You can create the function similar to this:\n\u0026#34; component for active windowfunction! StatuslineActive()\u0026#34; the component goes hereendfunction\u0026#34; component for inactive windowfunction! StatuslineInactive()\u0026#34; the component goes hereendfunction\u0026#34; load statusline using `autocmd` event with this functionfunction! StatuslineLoad(mode) if a:mode ==# \u0026#39;active\u0026#39;\u0026#34; to make it simple, %! is to evaluate the current changes in the window\u0026#34; it can be useful for evaluate current mode in statusline. For more info:\u0026#34; :help statusline. setlocal statusline=%!StatuslineActive() else setlocal statusline=%!StatuslineInactive() endifendfunctionand also the autocmd similar to this:\n\u0026#34; so that autocmd didn\u0026#39;t stack up and slow down vimaugroup statusline_startup autocmd!\u0026#34; for more info :help WinEnter and :help BufWinEnter autocmd WinEnter,BufWinEnter * call StatuslineLoad(\u0026#39;active\u0026#39;) autocmd WinLeave * call StatuslineLoad(\u0026#39;inactive\u0026#39;)augroup ENDNow we can compose our statusline component. We can take a look at :help statusline for supported items like for example f for relative path to the file in the buffer. You can choose whatever item you like in your statusline, and put it in the previous function similar to this:\nfunction! StatuslineActive()\u0026#34; if we want to add `f` items in our statusline let l:filename = \u0026#39;%f\u0026#39;\u0026#34; if we want to add \u0026#39;m\u0026#39; items in our statusline let l:mod = \u0026#39;%m\u0026#39;\u0026#34; the `.` is basically to ignore whitespace before and put it right after the previous component return l:filename.l:modendfunctionWhy we need to do that? well, I\u0026rsquo;ll explain it in next section\nCurrent Mode in Statusline If you want to put your current mode in your statusline, you can do it with a function similar to this:\nfunction! StatuslineMode() abort let l:currentmode={ \\ \u0026#39;n\u0026#39;: \u0026#39;N\u0026#39;, \\ \u0026#39;v\u0026#39;: \u0026#39;V\u0026#39;, \\ \u0026#39;V\u0026#39;: \u0026#39;VL\u0026#39;, \\ \u0026#39;^V\u0026#39;: \u0026#39;VB\u0026#39;, \\ \u0026#39;s\u0026#39;: \u0026#39;S\u0026#39;, \\ \u0026#39;S\u0026#39;: \u0026#39;SL\u0026#39;, \\ \u0026#39;^S\u0026#39;: \u0026#39;SB\u0026#39;, \\ \u0026#39;i\u0026#39;: \u0026#39;I\u0026#39;, \\ \u0026#39;R\u0026#39;: \u0026#39;R\u0026#39;, \\ \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \\ \u0026#39;t\u0026#39;: \u0026#39;T\u0026#39;} let l:modecurrent = mode()\u0026#34; use get() -\u0026gt; fails safely, since ^V doesn\u0026#39;t seem to register\u0026#34; 3rd arg is used when return of mode() == 0, which is case with ^V\u0026#34; thus, ^V fails -\u0026gt; returns 0 -\u0026gt; replaced with \u0026#39;VB\u0026#39; let l:modelist = toupper(get(l:currentmode, l:modecurrent, \u0026#39;VB\u0026#39;)) let l:current_status_mode = l:modelist return l:current_status_modeendfunctionand put it inside of your statusline function like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39;\u0026#34; `w:` is basically local variable to current window\u0026#34; and `l:` is basically local variable to function. For more info :help E121 let w:mode = \u0026#39;%{StatuslineMode()}\u0026#39; return w:mode.l:filename.l:modendfunctionNow, if we want to change the current mode background based on the current mode, we can do something like this:\n\u0026#34; define Normal mode color, Insert mode color, and so onhi NormalModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...hi InsertModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...function! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; %* is basically to restore highlight to StatusLine highlight group return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:modendfunctionGit Branch in Statusline If you install vim-fugitive plugin, then you can use fugitive#head() in your statusline like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; make sure it doesn\u0026#39;t throw an error if `vim-fugitive` is not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : \u0026#39;\u0026#39;}\u0026#34;\u0026#34; to separate left and right side let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionalternatively, you can use system() command to get the current git branch (for more info :help system()) like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; for more info :help E121 let g:gitbranchcmd = \u0026#34;git branch --show-current 2\u0026gt;/dev/null | tr -d \u0026#39;\\n\u0026#39;\u0026#34;\u0026#34; use system() if vim-fugitive not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : system(g:gitbranchcmd)}\u0026#34; let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionSame Statusline for active and inactive window Now, if we want our statusline to be the same whether in active or inactive window. We can make simplify it by only make one function and not using autocmd. It will look something like this:\nfunction! StatuslineComponent()\u0026#34; your component goes hereendfunctionset statusline=%!StatuslineComponent()and you can use some tips from previous section too!\nConclusion This guide is for do-it-yourself kind of people, so it\u0026rsquo;s only giving some pointer you can use to make your own statusline. I don\u0026rsquo;t want to tell you what to put in your statusline, it is your OWN statusline after all, so you need to know what you want in it. Also, I\u0026rsquo;m not a vim script expert so please forgive me if I miss something. If you have any question regarding this post, feel free to hit me up on twitter (@diawanchris)! See you later!\nReferences  Kade Killary blog post . Junegunn\u0026rsquo;s statusline .  "},{"ref":"https://bruhtus.github.io/posts/split-up-vimrc/","title":"Split Up Vimrc","section":"posts","tags":["Vim"],"date":"2021.03.22","body":" If you\u0026rsquo;re the type of person who like to place all your source code in one file, then this article is not for you. But, if you\u0026rsquo;re the type of person who like to split up your source code into a few sub-modules, then this article is for you.\n Skip-able Part When i look at my vimrc (vimrc is a vim config file for those who don\u0026rsquo;t know), i always feel confused where should i add new configuration for new plugin. I want to organize my vimrc so that it is easier to maintain and adding stuff, and that\u0026rsquo;s where the problem comes in.\nOvertime, when you keep adding configuration to vim, slowly your vimrc gonna become a huge mess and at some point it gonna feels cumbersome to access your vimrc. And that\u0026rsquo;s why i thought \u0026ldquo;can i split up my vimrc so that i don\u0026rsquo;t feel overwhelm every time i want to add new configuration or mapping to vim?\u0026rdquo; and it turns out i can.\nUpside and Downside Before we move on, you need to know the upside and downside for split up your vimrc that i\u0026rsquo;ve found. Here we go.\nUpside  Easier to manage, you can have a dedicated config file for every plugin you have Doesn\u0026rsquo;t overwhelm you with the piled up line of text, because it\u0026rsquo;s on separate file You can take a part of your config such as defaults setting and mappings, rather than a whole vim config (useful for accessing server with ssh)  Downside  You need to use grep or something similar if you want to check if the mapping already exist or not. If you didn\u0026rsquo;t split up your vimrc, you can just use vim built-in search function. You need to download a lot of file if you want to have full experience of your vim.  Split Up Vimrc If you still want to go on despite the downside, then it\u0026rsquo;s time to split up your vimrc.\nFirst thing first, you need to know that vim has runtime path which gonna be loaded everytime you start vim. And we can use the default runtime path to our advantage. For the full list, you can check here , but to make it simple, we\u0026rsquo;re only gonna use ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) directory. Every file in those directory get loaded every time you open vim, so you can add your config in those directory.\nFor example, you can move your defaults config such as set number relativenumber into file defaults.vim and place it in ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) and defaults config such as number and relativenumber gonna get loaded everytime you open vim.\nYou can also make config file for your plugin and give it the plugin name such as fugitive.vim and place it into ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin.\nThe Conclusion It\u0026rsquo;s quite easy to manage vim if you split up your vimrc, but it comes back to your personal preference. This article is just to remind vim user that they can split up their vimrc if they want to.\nReferences  Manage plugin in dark ages .  "}]