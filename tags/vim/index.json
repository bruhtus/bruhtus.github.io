[{"ref":"https://bruhtus.github.io/posts/configure-vim-as-intro-to-software-design/","title":"Configure Vim as Intro to Software Design","section":"posts","tags":["Vim"],"date":"2025.05.31","body":"As vim gaining popularity these days, I\u0026rsquo;ve heard some complaint about configuring vim is hard. Not only learning vim motions is hard, making vim usable for the user is also hard. Well, in case someone haven\u0026rsquo;t realize, configuring vim is basically a programming activity which can be a good thing or a bad thing, depending on your preferences.\nBecause configuring vim is hard for new user, some people created a pre-configured vim config that they can use. At the beginning, pre-configured vim config can help new user to focus more on learning or getting used to vim motions instead of going the rabbit hole of configuring vim. Pre-configured vim config can lower the overhead for new user, but it\u0026rsquo;s not the final destination. There are some benefits we can get by configuring vim from scratch, as configuring vim is basically doing some programming. To use the programming term, you can think of vim as a \u0026ldquo;runtime\u0026rdquo; and your configuration as a script to run in those \u0026ldquo;runtime\u0026rdquo;.\nSome people like the concept of configuration like vim, which some might say \u0026ldquo;configuring by programming\u0026rdquo;, and some people don\u0026rsquo;t like it. If you\u0026rsquo;re interested in using vim, I suggest you to take a look of what vim has to offer, like \u0026ldquo;configuring by programming\u0026rdquo; concept. And if that\u0026rsquo;s not your cup of tea, then maybe vim is not for you and maybe you can learn only the vim motions instead. I treat vim, the text editor, and vim motions separately because I think both of them have their own benefits independently.\nSo, what kind of benefits we can get when we try to configure vim? One of the benefits of configuring vim from scratch is that we learn about \u0026ldquo;execution order\u0026rdquo;. You might be thinking, \u0026ldquo;isn\u0026rsquo;t that the basic of programming?\u0026rdquo;. Well, you might be surprised that some programmer or software developer didn\u0026rsquo;t even care or, worse, didn\u0026rsquo;t even know about the execution order. One example from my workplace is that some developer using forEach() in javascript to do some looping, regardless of asynchronous or synchronous operation. And then one of the developers use forEach() to looping through a list of asynchronous operation. And for some reason, those developer is moved to another project. And then I got assigned to those project, and let me tell you, those looping is causing a race condition in the software because forEach() didn\u0026rsquo;t handle asynchronous operation, and I\u0026rsquo;m the one who need to fix that. Because of configuring vim, I make a habit of being conscious about the execution order, which operation get executed first. And so, that\u0026rsquo;s the first thing I checked, what order the operation get executed? And that\u0026rsquo;s where I found those \u0026ldquo;illegal racing\u0026rdquo; in the source code.\nYou might be thinking, \u0026ldquo;isn\u0026rsquo;t that kind of thinking process will come with experience?\u0026rdquo;. Yes, you\u0026rsquo;re right, and configuring vim help me to have those kind of thinking process earlier than my peer, because vim \u0026ldquo;forced\u0026rdquo; me to be mindful of the execution order of my config. It\u0026rsquo;s like what my senior software developer always said, we need to hone our \u0026ldquo;common sense\u0026rdquo; and configuring vim helping me honing my \u0026ldquo;common sense\u0026rdquo;.\nAnother thing is that because of the concept \u0026ldquo;configuring by programming\u0026rdquo;, we can also extend the functionality of vim. For example, if you know about grep tools in unix-like environment, you might already know that vim has those functionality built-in with :grep command (for more info on :help :grep). Personally, I don\u0026rsquo;t really like the default functionality of :grep command, so I make my own implementation that have the same same functionality as :grep command, which is to search any line that have the same words as the input words. Honestly, that kind of experience, creating my own implementation of some feature is exciting because I get to design the mechanism from how the user interact with the feature until how to present the result.\nOf course what I did is not as complex as most software out there, but I think we should try to design a small mechanism first before we go into a complex mechanism. And that\u0026rsquo;s why I think configuring vim is a nice intro to designing a software. You get to try to make a simple mechanism that you need or want, and going up to something like lazy loading mechanism, which can be quite complex depending on your design and expected results.\nPlease keep in mind that this is not only limited to vim, we can also get the same benefits with other software that implement \u0026ldquo;configuring by programming\u0026rdquo; concept. I just use vim as an example because for me, it\u0026rsquo;s the easiest software to start with. When I start configuring vim back in the day, my vim config is not as complex as it is now. I only have one file for my vim config back then, nowadays tho, I need a whole directory to hold all my vim config. You could say that the more I know about vim, the more my vim config grow. It\u0026rsquo;s like our vim config is growing with us, so you don\u0026rsquo;t need to know everything from the start, take your time and enjoy the process of finding things out in vim.\nAlright, that\u0026rsquo;s all from me. Happy vimming!\n"},{"ref":"https://bruhtus.github.io/posts/remove-specific-line-in-vim/","title":"Remove Specific Line in Vim","section":"posts","tags":["Notes","Vim"],"date":"2022.09.03","body":"A Brief Intro In this post, we will talk about how to remove specific line in vim. We will be using this javascript snippet code as an example:\nconst app = require(\u0026#39;./jest-example\u0026#39;); const math = require(\u0026#39;./math\u0026#39;); describe(\u0026#39;app operation\u0026#39;, () =\u0026gt; { const multiplyMock = jest.spyOn(math, \u0026#39;multiply\u0026#39;); multiplyMock.mockReturnValue(\u0026#39;itu\u0026#39;); test(\u0026#39;call math.add()\u0026#39;, () =\u0026gt; { const add = jest.spyOn(math, \u0026#39;add\u0026#39;); add.mockImplementation(() =\u0026gt; \u0026#39;anu\u0026#39;); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(\u0026#39;anu\u0026#39;); add.mockRestore(); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(3); }); test(\u0026#39;call math.subtract()\u0026#39;, () =\u0026gt; { const subtract = jest.spyOn(math, \u0026#39;subtract\u0026#39;); subtract.mockImplementation(() =\u0026gt; \u0026#39;nganu\u0026#39;); console.log(app.doSubtract(1, 2)); expect(app.doSubtract(1, 2)).toBe(\u0026#39;nganu\u0026#39;); }); test(\u0026#39;call math.subtract() again\u0026#39;, () =\u0026gt; { console.log(app.doSubtract(1, 2)); }); test(\u0026#39;call math.multiply()\u0026#39;, () =\u0026gt; { console.log(app.doMultiply(1, 2)); }); }); And the goal is to remove line that has console.log() in it. Let\u0026rsquo;s get started!\nGlobal Command The first solution is that, we can use global command to delete the line that has console.log() like this:\n:g/console.log/dPlease keep in mind that the term delete in vim, means cut. So, rather than deleting the content, vim will put that into the unnamed register. For more info about unnamed register, we can check on :help registers.\nSo, if we didn\u0026rsquo;t want to clutter our unnamed register, we can use black hole register (yup, that\u0026rsquo;s a thing) which actually delete rather than cut like this:\n:g/console.log/d_On a side note, we don\u0026rsquo;t need to use / as the separator between command and pattern, we can use most characters except \\, \u0026quot;, or |. If we use vim9 script, we can use # as a separator either, so please keep that in mind. For more info, we can check on :help pattern-delimiter.\nIn other words, we can write the previous global command, like this:\n:g;console.log;d_The global command that we just gone through will delete all the console.log in current file. If we want to specify the area of console.log we want to delete, we can add range to global command.\nLet\u0026rsquo;s take a look at the snippet we are using:\nconst app = require(\u0026#39;./jest-example\u0026#39;); const math = require(\u0026#39;./math\u0026#39;); describe(\u0026#39;app operation\u0026#39;, () =\u0026gt; { const multiplyMock = jest.spyOn(math, \u0026#39;multiply\u0026#39;); multiplyMock.mockReturnValue(\u0026#39;itu\u0026#39;); test(\u0026#39;call math.add()\u0026#39;, () =\u0026gt; { const add = jest.spyOn(math, \u0026#39;add\u0026#39;); add.mockImplementation(() =\u0026gt; \u0026#39;anu\u0026#39;); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(\u0026#39;anu\u0026#39;); add.mockRestore(); console.log(app.doAdd(1, 2)); expect(app.doAdd(1, 2)).toBe(3); }); test(\u0026#39;call math.subtract()\u0026#39;, () =\u0026gt; { const subtract = jest.spyOn(math, \u0026#39;subtract\u0026#39;); subtract.mockImplementation(() =\u0026gt; \u0026#39;nganu\u0026#39;); console.log(app.doSubtract(1, 2)); expect(app.doSubtract(1, 2)).toBe(\u0026#39;nganu\u0026#39;); }); test(\u0026#39;call math.subtract() again\u0026#39;, () =\u0026gt; { console.log(app.doSubtract(1, 2)); }); test(\u0026#39;call math.multiply()\u0026#39;, () =\u0026gt; { console.log(app.doMultiply(1, 2)); }); }); And let\u0026rsquo;s say that our cursor in the line test('call math.subtract()', () =\u0026gt; { and we want to delete the console.log in test('call math.add()', () =\u0026gt; { which is before the line we\u0026rsquo;re currently in.\nWith that in mind, we can do something like this:\n:?test?;/});/g;console.log;d_Here\u0026rsquo;s the breakdown of those command:\n ?test? will search word test on previous line. ; after ?test? is a special offset which tell vim that we will use another search command. For more info, we can check :help //;. /});/ will search after the result of previous search. g;console.log;d_ is a global command to delete console.log in the scope of previous search.  Substitute Command The downside of global command is that there\u0026rsquo;s no confirm option, so we might delete something we don\u0026rsquo;t want to. If we want a confirm option, we can use substitute command.\nIf we want to delete all the console.log in current file, we can do it like this:\n:%s;.*console.log.*\\n;;cHere\u0026rsquo;s the breakdown of those command:\n % symbol to tell vim that the range is the current file or all the line in the file. s is the abbreviation of substitute command. .*console.log.*\\n is the pattern that select the line that has console.log in it, which include the newline character at the end. ;; is basically telling vim to replace it with nothing. c is a confirm option.  We can also combine substitute command with global command, like this:\n:g;console.log;s;.*\\n;;cConclusion There\u0026rsquo;s a lot of possibility with global and substitute command and we won\u0026rsquo;t be able to cover all of those in one blog post. So, i will leave it to you to explore those possibility.\nYou might want to learn regular expression to enhance the global and substitute command experience.\nAlright, that\u0026rsquo;s it for this post. Thank you for reading!\n"},{"ref":"https://bruhtus.github.io/posts/vim-statusline/","title":"Guide to Make Your Own Vim/Neovim Statusline","section":"posts","tags":["Vim"],"date":"2021.08.20","body":" We don\u0026rsquo;t have to install vim plugin to get a statusline if we don\u0026rsquo;t want to.\n Introduction Hi everyone! In this post I will talk about making your custom statusline in vim. There are a lot of plugins out there that makes vim statusline way better and works out of the box.\n\u0026ldquo;Why would someone going through all the trouble while there\u0026rsquo;s a plugin for that?\u0026rdquo;, you might ask. Well, for me personally, having one less plugin is a good thing. I don\u0026rsquo;t really want to depend on the plugin for something simple such as statusline. If I can build it myself, then I will build it myself rather than using a plugin. Also, it save me a lot of time to figure out which plugin causes the issue if I have less plugin! Oh, another thing, some vim statusline plugin can slow down your startup time (I\u0026rsquo;m looking at you vim-airline) so be careful about that. Alright then, let\u0026rsquo;s get into it!\nRequirements Before we start, we need to prepare a few things:\n Vim/Neovim (we will use vim script or VimL in this post) set laststatus=2 (always display the statusline) Patience (don\u0026rsquo;t be scared when you see an error, calm down!)  If all is set, then let\u0026rsquo;s get started!\nDisable Old Statusline Before we move further, you need to disable or remove your old statusline plugin and the config. If you don\u0026rsquo;t want to remove your old statusline plugin config, you can commented out those line/config in your vimrc or init.vim.\nDifferent statusline for active and inactive window You can have different statusline for active and inactive window by using autocmd event. \u0026ldquo;What is autocmd?\u0026rdquo; you might ask, go take a look at :help autocmd for more info. To make it simple, autocmd is to automatically execute a command on certain event which you can check on :help autocmd-events for more info.\nSo, how can we have different statusline for active and inactive window? First, we need to make a function to define our active or inactive statusline component. You can create the function similar to this:\n\u0026#34; component for active windowfunction! StatuslineActive()\u0026#34; the component goes hereendfunction\u0026#34; component for inactive windowfunction! StatuslineInactive()\u0026#34; the component goes hereendfunction\u0026#34; load statusline using `autocmd` event with this functionfunction! StatuslineLoad(mode) if a:mode ==# \u0026#39;active\u0026#39;\u0026#34; to make it simple, %! is to evaluate the current changes in the window\u0026#34; it can be useful for evaluate current mode in statusline. For more info:\u0026#34; :help statusline. setlocal statusline=%!StatuslineActive() else setlocal statusline=%!StatuslineInactive() endifendfunctionand also the autocmd similar to this:\n\u0026#34; so that autocmd didn\u0026#39;t stack up and slow down vimaugroup statusline_startup autocmd!\u0026#34; for more info :help WinEnter and :help BufWinEnter autocmd WinEnter,BufWinEnter * call StatuslineLoad(\u0026#39;active\u0026#39;) autocmd WinLeave * call StatuslineLoad(\u0026#39;inactive\u0026#39;)augroup ENDNow we can compose our statusline component. We can take a look at :help statusline for supported items like for example f for relative path to the file in the buffer. You can choose whatever item you like in your statusline, and put it in the previous function similar to this:\nfunction! StatuslineActive()\u0026#34; if we want to add `f` items in our statusline let l:filename = \u0026#39;%f\u0026#39;\u0026#34; if we want to add \u0026#39;m\u0026#39; items in our statusline let l:mod = \u0026#39;%m\u0026#39;\u0026#34; the `.` is basically to ignore whitespace before and put it right after the previous component return l:filename.l:modendfunctionWhy we need to do that? well, I\u0026rsquo;ll explain it in next section\nCurrent Mode in Statusline If you want to put your current mode in your statusline, you can do it with a function similar to this:\nfunction! StatuslineMode() abort let l:currentmode={ \\ \u0026#39;n\u0026#39;: \u0026#39;N\u0026#39;, \\ \u0026#39;v\u0026#39;: \u0026#39;V\u0026#39;, \\ \u0026#39;V\u0026#39;: \u0026#39;VL\u0026#39;, \\ \u0026#39;^V\u0026#39;: \u0026#39;VB\u0026#39;, \\ \u0026#39;s\u0026#39;: \u0026#39;S\u0026#39;, \\ \u0026#39;S\u0026#39;: \u0026#39;SL\u0026#39;, \\ \u0026#39;^S\u0026#39;: \u0026#39;SB\u0026#39;, \\ \u0026#39;i\u0026#39;: \u0026#39;I\u0026#39;, \\ \u0026#39;R\u0026#39;: \u0026#39;R\u0026#39;, \\ \u0026#39;c\u0026#39;: \u0026#39;C\u0026#39;, \\ \u0026#39;t\u0026#39;: \u0026#39;T\u0026#39;} let l:modecurrent = mode()\u0026#34; use get() -\u0026gt; fails safely, since ^V doesn\u0026#39;t seem to register\u0026#34; 3rd arg is used when return of mode() == 0, which is case with ^V\u0026#34; thus, ^V fails -\u0026gt; returns 0 -\u0026gt; replaced with \u0026#39;VB\u0026#39; let l:modelist = toupper(get(l:currentmode, l:modecurrent, \u0026#39;VB\u0026#39;)) let l:current_status_mode = l:modelist return l:current_status_modeendfunctionand put it inside of your statusline function like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39;\u0026#34; `w:` is basically local variable to current window\u0026#34; and `l:` is basically local variable to function. For more info :help E121 let w:mode = \u0026#39;%{StatuslineMode()}\u0026#39; return w:mode.l:filename.l:modendfunctionNow, if we want to change the current mode background based on the current mode, we can do something like this:\n\u0026#34; define Normal mode color, Insert mode color, and so onhi NormalModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...hi InsertModeColor ctermbg=... ctermfg=... guifg=#... guibg=#...function! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; %* is basically to restore highlight to StatusLine highlight group return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:modendfunctionGit Branch in Statusline If you install vim-fugitive plugin, then you can use fugitive#head() in your statusline like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; make sure it doesn\u0026#39;t throw an error if `vim-fugitive` is not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : \u0026#39;\u0026#39;}\u0026#34;\u0026#34; to separate left and right side let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionalternatively, you can use system() command to get the current git branch (for more info :help system()) like this:\nfunction! StatuslineActive() let l:filename = \u0026#39;%f\u0026#39; let l:mod = \u0026#39;%m\u0026#39; if mode() ==# \u0026#39;n\u0026#39; let w:mode = \u0026#39;%#NormalModeColor#%{StatuslineMode()}\u0026#39; elseif mode() ==# v:insertmode let w:mode = \u0026#39;%#InsertModeColor#%{StatuslineMode()}\u0026#39; endif\u0026#34; for more info :help E121 let g:gitbranchcmd = \u0026#34;git branch --show-current 2\u0026gt;/dev/null | tr -d \u0026#39;\\n\u0026#39;\u0026#34;\u0026#34; use system() if vim-fugitive not installed let l:git = \u0026#34;%{exists(\u0026#39;*FugitiveHead\u0026#39;) ? fugitive#head() : system(g:gitbranchcmd)}\u0026#34; let l:sep = \u0026#39;%=\u0026#39; return w:mode.\u0026#39;%* \u0026#39;.l:filename.l:mod.l:sep.l:gitendfunctionSame Statusline for active and inactive window Now, if we want our statusline to be the same whether in active or inactive window. We can make simplify it by only make one function and not using autocmd. It will look something like this:\nfunction! StatuslineComponent()\u0026#34; your component goes hereendfunctionset statusline=%!StatuslineComponent()and you can use some tips from previous section too!\nConclusion This guide is for do-it-yourself kind of people, so it\u0026rsquo;s only giving some pointer you can use to make your own statusline. I don\u0026rsquo;t want to tell you what to put in your statusline, it is your OWN statusline after all, so you need to know what you want in it. Also, I\u0026rsquo;m not a vim script expert so please forgive me if I miss something. If you have any question regarding this post, feel free to hit me up on twitter (@diawanchris)! See you later!\nReferences  Kade Killary blog post . Junegunn\u0026rsquo;s statusline .  "},{"ref":"https://bruhtus.github.io/posts/split-up-vimrc/","title":"Split Up Vimrc","section":"posts","tags":["Vim"],"date":"2021.03.22","body":" If you\u0026rsquo;re the type of person who like to place all your source code in one file, then this article is not for you. But, if you\u0026rsquo;re the type of person who like to split up your source code into a few sub-modules, then this article is for you.\n Skip-able Part When i look at my vimrc (vimrc is a vim config file for those who don\u0026rsquo;t know), i always feel confused where should i add new configuration for new plugin. I want to organize my vimrc so that it is easier to maintain and adding stuff, and that\u0026rsquo;s where the problem comes in.\nOvertime, when you keep adding configuration to vim, slowly your vimrc gonna become a huge mess and at some point it gonna feels cumbersome to access your vimrc. And that\u0026rsquo;s why i thought \u0026ldquo;can i split up my vimrc so that i don\u0026rsquo;t feel overwhelm every time i want to add new configuration or mapping to vim?\u0026rdquo; and it turns out i can.\nUpside and Downside Before we move on, you need to know the upside and downside for split up your vimrc that i\u0026rsquo;ve found. Here we go.\nUpside  Easier to manage, you can have a dedicated config file for every plugin you have Doesn\u0026rsquo;t overwhelm you with the piled up line of text, because it\u0026rsquo;s on separate file You can take a part of your config such as defaults setting and mappings, rather than a whole vim config (useful for accessing server with ssh)  Downside  You need to use grep or something similar if you want to check if the mapping already exist or not. If you didn\u0026rsquo;t split up your vimrc, you can just use vim built-in search function. You need to download a lot of file if you want to have full experience of your vim.  Split Up Vimrc If you still want to go on despite the downside, then it\u0026rsquo;s time to split up your vimrc.\nFirst thing first, you need to know that vim has runtime path which gonna be loaded everytime you start vim. And we can use the default runtime path to our advantage. For the full list, you can check here , but to make it simple, we\u0026rsquo;re only gonna use ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) directory. Every file in those directory get loaded every time you open vim, so you can add your config in those directory.\nFor example, you can move your defaults config such as set number relativenumber into file defaults.vim and place it in ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin (for neovim) and defaults config such as number and relativenumber gonna get loaded everytime you open vim.\nYou can also make config file for your plugin and give it the plugin name such as fugitive.vim and place it into ~/.vim/plugin (for vanilla vim) or ~/.config/nvim/plugin.\nThe Conclusion It\u0026rsquo;s quite easy to manage vim if you split up your vimrc, but it comes back to your personal preference. This article is just to remind vim user that they can split up their vimrc if they want to.\nReferences  Manage plugin in dark ages .  "}]