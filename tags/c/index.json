[{"ref":"https://bruhtus.github.io/posts/pointer-in-c-warehouse-analogy/","title":"Pointer in C: Warehouse Analogy","section":"posts","tags":["C"],"date":"2025.11.05","body":"At the time of writing this post, i am still learning about C programming language, and one of the topics about C programming language is \u0026ldquo;pointer\u0026rdquo;. I know that there\u0026rsquo;s a lot of analogy about pointers out there, one of the common one is about house and house address, but i want to share the analogy that help me understand about pointer.\nImagine there\u0026rsquo;s a company called RAM and those company business is renting out warehouses. And then we, as the customer, want to rent one of their warehouses.\nWhen we rent the warehouse, we got the following item:\n The warehouse key. The keychain with warehouse information on the key.  Before we go further, think of the \u0026ldquo;warehouse\u0026rdquo; as data storage (a.k.a memory), the \u0026ldquo;warehouse key\u0026rdquo; as the pointer in C, and the \u0026ldquo;keychain\u0026rdquo; as the address that we save in those pointer. We can think of the \u0026ldquo;keychain\u0026rdquo; as the value of the \u0026ldquo;key\u0026rdquo;.\nIf we want to get \u0026ldquo;something\u0026rdquo; inside the warehouse, we need to use the \u0026ldquo;key\u0026rdquo; to open the warehouse. We can think of \u0026ldquo;opening\u0026rdquo; the warehouse using the \u0026ldquo;key\u0026rdquo; as dereferencing a pointer, and the effect of \u0026ldquo;opening\u0026rdquo; the warehouse is that we got \u0026ldquo;something\u0026rdquo; from inside the warehouse.\nNow, let\u0026rsquo;s say that we have a \u0026ldquo;key\u0026rdquo; but we don\u0026rsquo;t have the \u0026ldquo;keychain\u0026rdquo;, how do we know which warehouse we are supposed to open? This situation will cause confusion for us, and it\u0026rsquo;s also similar for the computer. This situation can be illustrated with this C code:\nint main(void) { int *p; *p = 69; return 0; } The above code means that we are trying to put 69 into the warehouse, but we did not give which warehouse we are supposed to use. If we try running those code (after we compiled it), we will get segmentation fault error, which basically means that the computer can not access the memory because there\u0026rsquo;s no information about the memory that the computer supposed to use.\nTo solve those problem, we can give information about which \u0026ldquo;warehouse\u0026rdquo; to use like this:\nint main(void) { int i; int *p; p = \u0026amp;i; *p = 69; return 0; } The above code means that we put the address of warehouse i in our \u0026ldquo;keychain\u0026rdquo; so that we know which warehouse to use, and we can put 69 in our warehouse. This is also the case with computer, now the computer is not confused anymore and won\u0026rsquo;t throw segmentation fault error.\nThere\u0026rsquo;s also a case with dangling pointer, which basically means that the \u0026ldquo;key\u0026rdquo; and the \u0026ldquo;keychain\u0026rdquo; is exist but the warehouse is already demolished. So when we are trying to \u0026ldquo;open\u0026rdquo; the warehouse, we can\u0026rsquo;t find the specified warehouse from the information on the \u0026ldquo;keychain\u0026rdquo; and here comes another confusion. I will leave it up to you to try out dangling pointer and other pointer case.\nAlright, that\u0026rsquo;s it. See you next time!\n"},{"ref":"https://bruhtus.github.io/posts/difference-between-i++-and-++i-in-c/","title":"Difference Between i++ and ++i in C","section":"posts","tags":["C"],"date":"2025.11.04","body":"A Brief Explanation Let\u0026rsquo;s say we have int i = 0;, and imagine there\u0026rsquo;s a temporary object (rvalue?) to store the result of i + 1 for the ++ operator.\n Object is an area of memory that is used by our program, and temporary object in here means that the object has a temporary duration and will be deleted when the containing full expression ends.\nFull expression here means:\n The complete expression that forms an expression statement (with terminating semicolon (;) at the end). One of the controlling expression if, switch, while, for, or do-while statement. The expression of an initializer (like int i = 0;). return statement.   This is what probably happen if we use i++ without assigned the result to another variable:\n// i++; tmp = i; i = i + 1; This is what probably happen if we use ++i without assigned the result to another variable:\n// ++i; i = i + 1; tmp = i; This is what probably happen if we use i++ when assigned the result to variable j:\n// int j = i++; tmp = i; j = tmp; i = i + 1; This is what probably happen if we use ++i when assigned the result to variable j:\n// int j = ++i; i = i + 1; tmp = i; j = tmp; The only difference between i++ and ++i is when we use the value of the operation in the same statement, like int j = ++i.\nP.S:\nAt the time of writing this post, i am still learning about C, so this illustration might be wrong. Please let me know if there are a better illustration about this.\ni++ or ++i in For Loop When using either i++ or ++i in for-loop like this:\nint i; for (i = 0; i \u0026lt; 5; i++) printf(\u0026#34;%d\\n\u0026#34;, i); for (i = 0; i \u0026lt; 5; i++) printf(\u0026#34;%d\\n\u0026#34;, i); Both of them will operate identically because the increment of i and the print statement is in different line. It\u0026rsquo;s like we are using i++ or ++i without any assignment like this:\nint i = 0; i++; ++i; printf(\u0026#34;%d\\n\u0026#34;, i); Side Note Please keep in mind that operation i++ and ++i is also prone to integer overflow.\nHere an overflow example:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;limits.h\u0026gt; int main(void) { unsigned int i = UINT_MAX; printf(\u0026#34;before increment i: %d\\n\u0026#34;, i); i++; printf(\u0026#34;after increment i: %d\\n\u0026#34;, i); return 0; } In the example above, as we store the maximum value of unsigned integer in i and when we increase the value of i, the result would be 0 because the value is more than the maximum value of unsigned integer, so it result in overflow.\nReferences  Stackoverflow about difference between i++ and ++i . About temporary object . About integer overflow . Unsigned integers overflow . Cppreference object lifetime . Cppreference statements .  "}]