[{"ref":"https://bruhtus.github.io/posts/pointer-to-array-in-c/","title":"Pointer to Array in C: Compression File Analogy","section":"posts","tags":["C"],"date":"2025.12.24","body":"DISCLAIMER Keep in mind that this is only an analogy to help newcomer understand pointer to array in C programming language. This does not mean there\u0026rsquo;s any sort of compression when we use pointer to array.\n\u0026amp;arr vs \u0026amp;arr[0] In case you didn\u0026rsquo;t know, we can get the address of an array using the address-of operator like \u0026amp;array. Here\u0026rsquo;s an example:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int arr[2]; printf(\u0026#34;\u0026amp;arr: %p\\n\u0026#34;, \u0026amp;arr); // Address to _whole array_.  printf(\u0026#34;\u0026amp;arr[0]: %p\\n\u0026#34;, \u0026amp;arr[0]); // Address to _element of array_.  return 0; } From the example above, you might be thinking, \u0026ldquo;isn\u0026rsquo;t \u0026amp;arr and \u0026amp;arr[0] print out the same value, what is the difference?\u0026rdquo;. The difference is not in the value itself, but in the implication.\n\u0026amp;arr and \u0026amp;arr[0] (or we can just use arr, because array name represent the index 0 memory address) has the same value, which is the memory address at index 0 because the beginning of the array is also at the index 0 of the array. The difference is at the end.\nWhen we use \u0026amp;arr, the end of that expression is the end on the last element of array. Let\u0026rsquo;s say we store integer value in 4 bytes and each memory address correspond to 1 byte. The whole array memory address can be represented like this (the empty line used to give clarity, the actual memory scheme is contiguous):\n001 \u0026lt;- the beginning of index 0 __and__ the beginning of array 002 003 004 \u0026lt;- the end of index 0 005 \u0026lt;- the beginning of index 1 006 007 008 \u0026lt;- the end of index 1 __and__ the end of array With the representation above, the expression \u0026amp;arr means that we got the beginning of array until the end of array. Meanwhile, the expression \u0026amp;arr[0] means that we got the beginning of index 0 until the end of index 0.\nPointer to Array With that out of the way, let\u0026rsquo;s get into pointer to array. We can declare pointer to array like this:\nchar (*arr)[4]; What the above declaration means is that \u0026ldquo;a pointer to an array of 4 char\u0026rdquo;. And then, you might be thinking, \u0026ldquo;how do we give value to those arr variable?\u0026rdquo;. One of them is like this:\nchar anu[4] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;\\0\u0026#39;}; char (*arr)[4] = \u0026amp;anu; // Assigning memory address of anu array. Another one is like this:\nchar (*arr)[4] = \u0026amp;\u0026#34;abc\u0026#34;; // Assigning memory address of string literal. Or we can split those initialization with declaration and assignment like this:\nchar (*arr)[4]; // Declaration of arr variable. arr = \u0026amp;\u0026#34;abc\u0026#34;; // Assignment of arr variable. Let\u0026rsquo;s talk about the first example. In the first example, we are using memory address of anu array of 4 characters for the value of arr, which is \u0026ldquo;a pointer to the array of 4 characters\u0026rdquo;.\nNow the question is that, how do we get the character b from arr variable? You might be thinking, \u0026ldquo;can\u0026rsquo;t we just use indexing like arr[1]?\u0026rdquo; Remember that we got the whole array inside arr variable and square bracket or array subscript is another form of dereference. So when we are trying to deference the arr variable like *arr or arr[0], we got the whole array instead of element of array. And when we do arr[1] for char (*arr)[4];, we are actually trying to access the next memory after the whole array which is unallocated memory and result in undefined behavior. We can\u0026rsquo;t be sure what is in there.\n Keep in mind that arr[1] is equivalent to *(arr + 1), which means that we are dereferencing 1 offset from the index 0 arr memory address. 1 offset in here depends on how many bytes the variable type stored in memory.\n As for the second and third example, we need to know that string literal have a lifetime of static storage duration, which means that string literal will exist the entire execution of the program.\nWith that in mind, the expression \u0026amp;\u0026quot;abc\u0026quot; means that we got the memory address of the entire string literal, which in a way is an array of characters with different storage type than char []. If i understand correctly, char [] has automatic storage duration, so it will be deallocated at some point during the execution, usually when the function returns or the declaration goes out of scope.\nThe expression char (*arr)[4] = \u0026amp;\u0026quot;abc\u0026quot;; means that we are passing the memory address of the entire string literal to arr variable.\nSo, how do we access the character in char (*arr)[4]? Well, we need to dereferencing the arr twice. The first dereference, like *arr or arr[0], is to get the entire array and the second dereference, like (*arr)[1] or *((*arr) + 1) or arr[0][1], is to get the element of array.\n Why do we use bracket around arr variable like (*arr)[1]? Because square bracket or array subscript have a higher priority than the dereference operator. If we write the expression like *arr[1], that expression is equal to *(arr[1]). We are parsing the square bracket or array subscript first and then parsing the dereference operator. By adding bracket, we can overwrite the default priority. This is called precedence.\nThe precedence only control how expression are parsed and which operators are grouped which operands. Precedence do not control the order of evaluation. To control the order of evaluation, we need to use sequence point.\n Compression File Analogy If you are new to C programming language, like i\u0026rsquo;m at the time of writing this blog post, you might get confused by the concept of \u0026ldquo;pointer to array\u0026rdquo;. If you are confused, this analogy might help you to understand what is going on.\nImagine we have a ZIP file, which is one of the compression file format. Inside those ZIP file, we have directory called 001. Inside those directory, we have a file called 001 and 005 (see the representation of whole array at the beginning of the post).\nHere\u0026rsquo;s the simple representation:\n The file 001 and 005 represent the array\u0026rsquo;s elements. The directory 001 represent the array itself. The ZIP file represent the pointer to the array.  Here\u0026rsquo;s the simple illustration:\npointer.zip |_ 001/ |_ 001 |_ 005 So, if we want to get the element inside the array 001/, we need to extract the pointer.zip first and then accessing the element inside the array 001/.\nBonus: accessing character of string literal Here\u0026rsquo;s another interesting thing about string literal that you might want to try:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;%c\\n\u0026#34;, \u0026#34;abc\u0026#34;[0]); return 0; } What is the output? Now, try to analyze what\u0026rsquo;s going on :)\nAlright, that\u0026rsquo;s it. See you next time!\nReferences  Stackoverflow answer about precedence and associativity . Example memory address of string literal . log2base2 explanation about pointer to array . Stackoverflow answer about dereferencing pointer to array . C-faq about 2-dimensional array .  "},{"ref":"https://bruhtus.github.io/posts/lvalue-in-c/","title":"Lvalue in C","section":"posts","tags":["C"],"date":"2025.12.23","body":"A Brief Into I am always confused when trying to understand what is considered an lvalue in C programming language, so let me try to explain that to make me have a better understanding of lvalue in C.\nWhat is Lvalue? From C committee draft definition :\n An lvalue is an expression (with an object type other than void) that potentially designates an object; if an lvalue does not designate an object when it is evaluated, the behavior is undefined.\n And from C committee draft the origin of lvalue term :\n The name \u0026ldquo;lvalue\u0026rdquo; comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object \u0026ldquo;locator value\u0026rdquo;.\n Here\u0026rsquo;s another explanation about lvalue from GNU C intro:\n An expression that identifies a memory space that holds a value is called an lvalue, because it is a location that can hold a value.\n With that in mind, lvalue is an expression that refers to the region of storage that can hold a value. Those storage can be memory or something else.\n The region of storage that can hold a value is called object.\n I think calling lvalue as locator value make it easier to understand than the usual terminology left value, because lvalue might not be on the left side of the statement.\nPointer Dereference is Lvalue Here\u0026rsquo;s an example of lvalue can be on the left side or right side:\nint num = 68; int *ptr = \u0026amp;num; /* * *ptr is an lvalue that\u0026#39;s on the left and right of statement. * The *ptr on the right undergo conversion from _lvalue to rvalue_. */ *ptr = *ptr + 1; The expression *ptr from example above is an lvalue because it refers to the memory space that can hold a value. Keep in mind that ptr is a variable that stored memory address as its value, that means ptr stored the address of another region of storage. And dereferencing ptr or *ptr means that we are using those region of storage stored in ptr.\nLet\u0026rsquo;s say we have memory space in address 001 and 002, the num variable in previous example using the memory space at address 001 and the ptr variable using the memory space at address 002 which stored 001 inside it. Here\u0026rsquo;s a simple representation:\n num used memory space at 001 and stored value 68 inside of memory. ptr used memory space at 002 and stored value 001 inside of memory.  Variable is Lvalue When we define a variable like this:\nint num = 69; num is an lvalue because num refers to the memory space that hold value 69.\nNon-modifiable Lvalue Apparently lvalue is not always modifiable, there\u0026rsquo;s some region of storage we can not modify.\nFrom C committee draft about lvalue :\n A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.\n Basically we can not modify lvalue if it has:\n Array type. Incomplete type. Constant type. A structure or unions with one of its members as constant type.  Other than that, i assume we can modify the lvalue (?). I\u0026rsquo;m still not sure yet, at least by the time of writing this post. But the point is that, we can change the value in lvalue depending on lvalue modifiable or not. If the lvalue modifiable, we can change the value, if not, then we can\u0026rsquo;t change the value.\nAnyway, let\u0026rsquo;s check the constraint one by one.\nArray Type When we declare array like this:\nint array[2]; From what i understand, array is an lvalue because it refers to the memory space that can hold a value but, by the C standard, we can\u0026rsquo;t modify those lvalue with array type like this:\nint array[2]; array = 69; // This is invalid! I still have no idea why that\u0026rsquo;s the case, but if you are curious, you can read the development of the C language .\nIncomplete Type Incomplete type in here means that the type lacks size information, for example:\nstruct anu; anu is incomplete type because there is not enough information for the compiler to determine how much storage to set aside for struct anu type.\nHere\u0026rsquo;s another example of incomplete type:\nint itu[]; union ini; We cannot use the incomplete type like this:\nstruct anu nganu; unless we complete the type.\nBut, we can create a pointer to incomplete type like this:\nstruct anu *nganu; without completing the definition of struct anu. That is because a pointer just storing the memory address and we only need to know the pointer size, we don\u0026rsquo;t need to know the type size.\nConstant Type Well, as far as i understand, constant in C is read-only, which means that we can\u0026rsquo;t really change that.\nConstant Type in Struct or Union I\u0026rsquo;m still not sure about this one, but i kind of found an example. Here\u0026rsquo;s an example that will throw an error because of constant type in struct (using gcc):\nstruct something { const int size; }; int main(void) { struct something very_big; very_big.size = 69; return 0; } For some reason, the example above, which separate the declaration and assignment, trigger an error assignment of read-only member 'size', but if we use the initialization like this:\nstruct something { const int size; }; int main(void) { struct something very_big = {.size = 69}; return 0; } The example above didn\u0026rsquo;t give any error. So maybe the non-modifiable is during the assignment (?). Well, i\u0026rsquo;m still not sure.\nBonus: brief intro to rvalue This post is mainly exploring about lvalue because lvalue make me confused the most. Especially the dereference pointer statement, when i see some reference write about \u0026ldquo;*ptr is lvalue\u0026rdquo;, i\u0026rsquo;m like \u0026ldquo;but why can i put it on the right side like *ptr = *ptr + 1;?\u0026rdquo;. That is the primary reason i\u0026rsquo;m creating this post.\nBut other people usually also talking about rvalue. Here\u0026rsquo;s a footnotes from C committee draft :\n What is sometimes called \u0026ldquo;rvalue\u0026rdquo; is in this International Standard described as the \u0026ldquo;value of an expression\u0026rdquo;\n And that\u0026rsquo;s what i think about rvalue at the time of writing this post, a value of an expression. At the moment, i don\u0026rsquo;t really want to dive deep into what is considered an rvalue. One step at a time.\nThat\u0026rsquo;s it from me, see you next time!\nReferences  The Development of the C Language  Stackoverflow answer about lvalue in C . GNU C intro definition about lvalue in C . C committee draft about lvalue term origin . C committee draft about object . C committee draft lvalue definition . Stackoverflow answer why array type is a non-modifiable lvalue . Stackoverflow answer array type object is not modifiable . Eli\u0026rsquo;s post about lvalue and rvalue in C and C++ . cppreference about value categories .  "},{"ref":"https://bruhtus.github.io/posts/square-bracket-as-dereference-operator-in-c/","title":"Square Bracket as Dereference Operator in C","section":"posts","tags":["C"],"date":"2025.12.15","body":"When we learn another programming language for the first time, we were told that to access an array, we can use indexing. For example, let\u0026rsquo;s say we have an array with 5 items and the index array start at 0. With that in mind, we can access the 5th item in those array like array[4] (remember, the index start from 0, so it\u0026rsquo;s 0, 1, 2, 3, 4).\nBut in C programming language, array can \u0026ldquo;decay\u0026rdquo; into pointer, which means that in some cases, array can be treated like a pointer. Let\u0026rsquo;s say we have this array initialization:\nint array[2] = {69, 42}; And then, when we print the memory address of that array, we found out that the memory address of the variable array is equivalent to the memory address of the index 0 of array. We can check that by printing the memory address like this:\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int array[2] = {69, 42}; printf(\u0026#34;%p\\n\u0026#34;, array); // The memory address of array variable.  printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;array[0]); // The memory address of index 0 or first item.  return 0; } Now, you might be thinking \u0026ldquo;what is the correlation between that and dereference operator?\u0026rdquo;. Well, the thing is, square bracket is not only for array but can also be used with pointer in general.\nRemember that array stored as a \u0026ldquo;contiguous\u0026rdquo; block in the memory, which means that if we have the array with 2 items and the memory address of index 0 is 001, the memory address of index 1 is after the index 0.\nFor example, if our machine use 4 bytes to store integer value and we have 2 integer values in the array, the array take up 8 bytes in memory. With that in mind, if we have the memory address of the index 0 of that array as 001, then the memory address of index 1 is 005. Here\u0026rsquo;s what\u0026rsquo;s going on (assuming 1 memory address equal to 1 byte):\n Memory address 001 until 004 is for index 0. Memory address 005 until 010 is for index 1.  When we are dealing with array, we are also dealing with memory address as the value, not the actual value itself. And what is a pointer again? A variable that have memory address as a value. I think this is where the misunderstanding come around. As far as i understand, array can store more than 1 memory address but pointer can only store 1 memory address at a time. That\u0026rsquo;s why even though we are dealing with the same memory address as a value, the treatment for array and pointer is not the same. The similarity between array and pointer is dereference operation of memory address as a value.\nWhen we want to get the value stored in the memory address that the pointer had, we need to dereference those pointer. Here\u0026rsquo;s an example:\nint main(void) { int life = 42; int *p_life = \u0026amp;life; int age = *p_life; // Dereference pointer p_life to get value 42.  return 0; } In the previous example, we use asterisk (*) as a dereference operator, but we can also use square bracket like accessing array to dereference the pointer like this:\nint main(void) { int life = 42; int *p_life = \u0026amp;life; int age = p_life[0]; // Dereference pointer p_life to get value 42.  return 0; } When we are using the square bracket, we can think of the number inside those square bracket as offset. From the cplusplus.com tutorial , it seems like the square bracket is called offset operator. This means that when we do p_life[0], we are dereferencing a pointer with offset 0 and offset 0 means the current memory address. So if we have p_life[1], it means we are dereferencing a pointer p_life with offset 1 and the memory address that we are trying to dereferencing is 1 block of memory address after the stored memory address in pointer p_life, which we have or not have access to.\nTo make things easier to understand, let\u0026rsquo;s say p_life pointer stored memory address 001 that has integer value in it, and our machine use 4 bytes to store integer value in memory (similar to the previous array example). With that in mind, when we do p_life[0], we are dereferencing memory address 001. And when we do p_life[1], we are dereferencing memory address 005.\nIf you are still confused why we have 005 for the p_life[1], it\u0026rsquo;s because we take up 4 bytes of memory address with 001, 002, 003, and 004 (assuming 1 byte equal to 1 memory address) for p_life or p_life[0] (p_life with offset 0), so the start of the next block of memory is 005. That\u0026rsquo;s why p_life[1] memory address is 005.\nHere\u0026rsquo;s a representation in code:\nint main(void) { int life = 42; // life has 001 memory address.  int *p_life = \u0026amp;life; // Saving 001 memory address into p_life pointer.  int age = p_life[0]; // Getting the value from 001 memory address.  return 0; } With that in mind, the expression \u0026amp;array[0] can also be written as \u0026amp;(*array) which means get the memory address of \u0026ldquo;dereferencing array with offset 0\u0026rdquo; (?), yeah, i\u0026rsquo;m not sure what that\u0026rsquo;s called.\nWe can also using offset with asterisk operator too. Let\u0026rsquo;s say we want to dereference array with offset 1, we can do array[1] or *(array + 1) to dereference array with offset 1.\nMaybe indexing of array in another programming language is also dereference operator under the hood? I am not sure. Anyway, this is something interesting for me to learn and that\u0026rsquo;s why i write a blog post about it. That\u0026rsquo;s it, see you next time!\n"},{"ref":"https://bruhtus.github.io/posts/pointer-in-c-warehouse-analogy/","title":"Pointer in C: Warehouse Analogy","section":"posts","tags":["C"],"date":"2025.11.05","body":"At the time of writing this post, i am still learning about C programming language, and one of the topics about C programming language is \u0026ldquo;pointer\u0026rdquo;. I know that there\u0026rsquo;s a lot of analogy about pointers out there, one of the common one is about house and house address, but i want to share the analogy that help me understand about pointer.\nImagine there\u0026rsquo;s a company called RAM and those company business is renting out warehouses. And then we, as the customer, want to rent one of their warehouses.\nWhen we rent the warehouse, we got the following item:\n The warehouse key. The keychain with warehouse information on the key.  Before we go further, think of the \u0026ldquo;warehouse\u0026rdquo; as data storage (a.k.a memory), the \u0026ldquo;warehouse key\u0026rdquo; as the pointer in C, and the \u0026ldquo;keychain\u0026rdquo; as the address that we save in those pointer. We can think of the \u0026ldquo;keychain\u0026rdquo; as the value of the \u0026ldquo;key\u0026rdquo;.\nIf we want to get \u0026ldquo;something\u0026rdquo; inside the warehouse, we need to use the \u0026ldquo;key\u0026rdquo; to open the warehouse. We can think of \u0026ldquo;opening\u0026rdquo; the warehouse using the \u0026ldquo;key\u0026rdquo; as dereferencing a pointer, and the effect of \u0026ldquo;opening\u0026rdquo; the warehouse is that we got \u0026ldquo;something\u0026rdquo; from inside the warehouse.\nNow, let\u0026rsquo;s say that we have a \u0026ldquo;key\u0026rdquo; but we don\u0026rsquo;t have the \u0026ldquo;keychain\u0026rdquo;, how do we know which warehouse we are supposed to open? This situation will cause confusion for us, and it\u0026rsquo;s also similar for the computer. This situation can be illustrated with this C code:\nint main(void) { int *p; *p = 69; return 0; } The above code means that we are trying to put 69 into the warehouse, but we did not give which warehouse we are supposed to use. If we try running those code (after we compiled it), we will get segmentation fault error, which basically means that the computer can not access the memory because there\u0026rsquo;s no information about the memory that the computer supposed to use.\nTo solve those problem, we can give information about which \u0026ldquo;warehouse\u0026rdquo; to use like this:\nint main(void) { int i; int *p; p = \u0026amp;i; *p = 69; return 0; } The above code means that we put the address of warehouse i in our \u0026ldquo;keychain\u0026rdquo; so that we know which warehouse to use, and we can put 69 in our warehouse. This is also the case with computer, now the computer is not confused anymore and won\u0026rsquo;t throw segmentation fault error.\nThere\u0026rsquo;s also a case with dangling pointer, which basically means that the \u0026ldquo;key\u0026rdquo; and the \u0026ldquo;keychain\u0026rdquo; is exist but the warehouse is already demolished. So when we are trying to \u0026ldquo;open\u0026rdquo; the warehouse, we can\u0026rsquo;t find the specified warehouse from the information on the \u0026ldquo;keychain\u0026rdquo; and here comes another confusion. I will leave it up to you to try out dangling pointer and other pointer case.\nAlright, that\u0026rsquo;s it. See you next time!\n"},{"ref":"https://bruhtus.github.io/posts/difference-between-i++-and-++i-in-c/","title":"Difference Between i++ and ++i in C","section":"posts","tags":["C"],"date":"2025.11.04","body":"A Brief Explanation Let\u0026rsquo;s say we have int i = 0;, and imagine there\u0026rsquo;s a temporary object (rvalue?) to store the result of i + 1 for the ++ operator.\n Object is an area of memory that is used by our program, and temporary object in here means that the object has a temporary duration and will be deleted when the containing full expression ends.\nFull expression here means:\n The complete expression that forms an expression statement (with terminating semicolon (;) at the end). One of the controlling expression if, switch, while, for, or do-while statement. The expression of an initializer (like int i = 0;). return statement.   This is what probably happen if we use i++ without assigned the result to another variable:\n// i++; tmp = i; i = i + 1; This is what probably happen if we use ++i without assigned the result to another variable:\n// ++i; i = i + 1; tmp = i; This is what probably happen if we use i++ when assigned the result to variable j:\n// int j = i++; tmp = i; j = tmp; i = i + 1; This is what probably happen if we use ++i when assigned the result to variable j:\n// int j = ++i; i = i + 1; tmp = i; j = tmp; The only difference between i++ and ++i is when we use the value of the operation in the same statement, like int j = ++i.\nP.S:\nAt the time of writing this post, i am still learning about C, so this illustration might be wrong. Please let me know if there are a better illustration about this.\ni++ or ++i in For Loop When using either i++ or ++i in for-loop like this:\nint i; for (i = 0; i \u0026lt; 5; i++) printf(\u0026#34;%d\\n\u0026#34;, i); for (i = 0; i \u0026lt; 5; i++) printf(\u0026#34;%d\\n\u0026#34;, i); Both of them will operate identically because the increment of i and the print statement is in different line. It\u0026rsquo;s like we are using i++ or ++i without any assignment like this:\nint i = 0; i++; ++i; printf(\u0026#34;%d\\n\u0026#34;, i); Side Note Please keep in mind that operation i++ and ++i is also prone to integer overflow.\nHere an overflow example:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;limits.h\u0026gt; int main(void) { unsigned int i = UINT_MAX; printf(\u0026#34;before increment i: %d\\n\u0026#34;, i); i++; printf(\u0026#34;after increment i: %d\\n\u0026#34;, i); return 0; } In the example above, as we store the maximum value of unsigned integer in i and when we increase the value of i, the result would be 0 because the value is more than the maximum value of unsigned integer, so it result in overflow.\nReferences  Stackoverflow about difference between i++ and ++i . About temporary object . About integer overflow . Unsigned integers overflow . Cppreference object lifetime . Cppreference statements .  "}]