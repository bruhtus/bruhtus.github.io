[{"ref":"https://bruhtus.github.io/posts/git-rebase-chained-branch/","title":"Git Rebase Chained Branch","section":"posts","tags":["Git"],"date":"2025.04.18","body":"Let\u0026rsquo;s say we try to develop a feature B, but those feature need feature A which haven\u0026rsquo;t merged already. So, to prevent the diff changes getting larger, we create new branch to develop feature B. And then, in the middle of development of feature B, the branch that contains feature A got merged into main branch and all the commit from feature A got squashed into one commit. And when we try to rebase the feature B branch with main branch, we got a conflict from a commit which previously in feature A branch.\nTo make the situation clear, let\u0026rsquo;s take a look at this:\nBefore: A---B (main branch) \\ C---D (feature-A branch) \\ E---F (feature-B branch) After: A---B---G (main branch, with G commit as squashed C and D commit) \\ E---F (feature-B branch) The steps to make the conflict scenario are:\nmkdir git-test cd git-test git init -b main echo \u0026#39;first\u0026#39; \u0026gt; something git add something git commit -m \u0026#39;first\u0026#39; echo \u0026#39;second\u0026#39; \u0026gt;\u0026gt; something git commit -am \u0026#39;second\u0026#39; git checkout -b feature-A echo \u0026#39;third\u0026#39; \u0026gt;\u0026gt; something git commit -am \u0026#39;third\u0026#39; echo \u0026#39;fourth\u0026#39; \u0026gt;\u0026gt; something git commit -am \u0026#39;fourth\u0026#39; git checkout -b feature-B echo \u0026#39;fifth\u0026#39; \u0026gt;\u0026gt; something git commit -am \u0026#39;fifth\u0026#39; echo \u0026#39;sixth\u0026#39; \u0026gt;\u0026gt; something git commit -am \u0026#39;sixth\u0026#39; git checkout main git merge --squash feature-A git commit --no-edit git checkout feature-B git rebase main  To get out from the conflict, we can use git rebase --abort.\n Now, to prevent the conflict, instead of using git rebase, we can use git rebase --fork-point --onto like this:\ngit rebase --fork-point --onto main feature-A feature-B Flag --fork-point is to find the common commit point from main branch with feature-A branch and flag --onto is to change the parent commit from feature-A branch to main branch and apply the commit that exist in feature-B branch but not in feature-A branch \u0026ldquo;onto\u0026rdquo; main branch commit.\nNow, let\u0026rsquo;s say we have more than one branch that depends on feature A branch. Do we need to do git rebase --fork-point --onto ... multiple time? Well, fortunately there\u0026rsquo;s a flag --update-refs that will automatically do that for us.\nTo make the situation clear, let\u0026rsquo;s take a look at this:\nBefore: A---B (main branch) \\ C---D (feature-A branch) \\ E---F (feature-B branch) \\ G---H (feature-C branch) \\ I---J (feature-D branch) After: A---B---K (main branch, with K commit as squashed C and D commit) \\ E---F (feature-B branch) \\ G---H (feature-C branch) \\ I---J (feature-D branch) To use --update-refs, we need to rebase the top of the chained branch, which in the case above is feature-D branch. With that in mind, we can use this command:\ngit rebase --update-refs --onto main feature-A feature-D --onto main feature-A feature-D means rebase the range of commits in feature-A branch until feature-D branch on top of commits from main branch. We use feature-A because it\u0026rsquo;s the base branch for our chained branch and feature-D because it\u0026rsquo;s the top of the chained branch.\n We don\u0026rsquo;t need to use --fork-point to guess which common commit in all those branch because --update-refs already do that for us.\n Now, what should we do if we merge feature-B branch? The situation would be like this:\nBefore: A---B---K (main branch, with K commit as squashed C and D commit) \\ E---F (feature-B branch) \\ G---H (feature-C branch) \\ I---J (feature-D branch) After: A---B---K---L (main branch, with L commit as squashed E and F commit) \\ G---H (feature-C branch) \\ I---J (feature-D branch) We can use the same command as above but, instead of using feature-A, we use feature-B instead, like this:\ngit rebase --update-refs --onto main feature-B feature-D Next scenario, let\u0026rsquo;s say we create new branch feature-E from feature-D branch and add new commit in it. And then, we got some feedback for feature-C branch so we need to add new commit. The situation would be like this:\nBefore: A---B---K---L (main branch, with L commit as squashed E and F commit) \\ G---H---O (feature-C branch) \\ I---J (feature-D branch) \\ M---N (feature-E branch) With the situation above, we can checkout into feature-E branch or the top of the chained branch and use --update-refs like this:\ngit rebase --update-refs feature-C Alright, that\u0026rsquo;s it. See you next time!\nSide Note We can push all those branch as an atomic operation, which means, if one of the branch failed to push into a remote branch, the others branch won\u0026rsquo;t update the remote branch too. To do that, we can use flag --atomic in git push like this:\ngit push --atomic origin feature-C feature-D feature-E Please keep in mind that if you\u0026rsquo;re rebasing the git branch you want to push, you might need flag --force-with-lease in git push, like this:\ngit push --force-with-lease --atomic origin feature-C feature-D feature-E References  Stackoverflow git rebase \u0026ndash;onto answer . Women on rails git rebase \u0026ndash;onto an overview . Stackoverflow git rebase \u0026ndash;fork-point answer . Git rebase \u0026ndash;update-refs blog post   "},{"ref":"https://bruhtus.github.io/posts/manage-dotfiles-with-git/","title":"Manage Dotfiles With Git Working Repository","section":"posts","tags":["Notes","Linux","Git"],"date":"2024.04.08","body":"A Brief Intro For those who read this article without knowing what dotfiles are, it\u0026rsquo;s basically a configuration files. The purpose of backing up dotfiles is so that we don\u0026rsquo;t need to reconfigure our tools on a new system.\nThere are a lot of ways to backup and manage dotfiles, and one of them is using git.\nIn this article we will explore how to backup and manage dotfiles using git, the full working git repository rather than the bare one which a lot of people using.\nHow? What i like to do on my free time is browsing random stuff on internet without a goal, just mindlessly browsing some topic that i\u0026rsquo;m interested in and see if i could find something interesting. Letting your mind wondering, some people said.\nWhile i\u0026rsquo;m browsing on the internet about zsh, i found this github issue discussion about managing dotifles . And when i read through those discussions, i wonder if i can use the full working git repository, which basically the default git repository, rather than the bare one. So let\u0026rsquo;s try that, i guess.\nBack when i first trying to backup my dotfiles, i only know two method:\n Using git bare repository from atlassian article . Using GNU stow which i forgot where i learn that from.  The method i pick for my first dotfiles manager was git bare repository. The reason i go with git bare repository instead of GNU stow is that i don\u0026rsquo;t really want to mindlessly spend my inodes by creating a bunch of symlinks. I have experience with running out of inodes, which basically means that you have some storage left but you cannot create a new file. I know that linux or maybe unix-like system these day has quite a large number of inodes, but that does not mean i need to be wasteful of inodes, right?\nWhat bugging me for quite a while when using git bare repository to manage my dotfiles is that, do i really need to use the bare version of git repository to manage my dotfiles? And just recently i found that the answer is no.\nSo, how do we use the full git working directory, the default one instead of the bare one? It turns out that we can separate the git directory (the .git directory) and the working directory without using the bare repository!\nPlease keep in mind that my experience with git at the time is less than 6 months, maybe around 3 months. So it took me everything i got to just following the git bare dotfiles manager guide. Now, fast forward 2 years later, i made my own dotfiles manager using git. You can check them on my dotfiles repo here .\nThe key point of using git working repository instead of bare repository is this:\ngit --git-dir=\u0026#34;...\u0026#34; --work-tree=\u0026#34;...\u0026#34; init What the command above do is initialize git repository with the specified git directory and working directory. If we didn\u0026rsquo;t specified the working directory but specified the git directory, git will create the bare repository instead of working repository. The key part of this method is --git-dir=\u0026quot;...\u0026quot; --work-tree=\u0026quot;...\u0026quot;, so you might want to create an alias like this:\nalias config=\u0026#39;git --git-dir=\u0026#34;...\u0026#34; --work-tree=\u0026#34;...\u0026#34;\u0026#39; Now you might be wondering, why should we use working repository instead of bare repository? It\u0026rsquo;s because we will most likely change our dotfiles, which basically means we\u0026rsquo;re still \u0026ldquo;working\u0026rdquo; on the dotfiles. So it make more sense to use working repository instead of bare repository because we\u0026rsquo;re still changing something to repository. From what i know, git bare repository is good for sharing and backup files that we don\u0026rsquo;t really change. For example, let\u0026rsquo;s say you are afraid that github will suspend your account and you don\u0026rsquo;t have any backup for your private repository, so you basically lost your private repository. With git bare repository, you can setup a system that only save the git objects of the repo (the one inside .git directory) and update it regularly by pulling from the remote repository. And because you only save the git objects instead of the actual files, your storage usage is lower than storing the actual files. As far as i know, that\u0026rsquo;s the benefit of git bare repository. With that in mind, it\u0026rsquo;s make more sense to use a working repository instead of bare repository in this case.\nThere are 3 important step when we want to get the existing dotfiles on a new system:\n Initialize new git repo. Doing git reset, the default or --mixed one. Doing git checkout.  We already talking about the initialize part for a bit before, which basically just the usual git init. Now let\u0026rsquo;s talk about the git reset part. git reset or git reset --mixed is basically reset the index or staging area on current branch with specific commit. That means, if we don\u0026rsquo;t have any commit on current branch, git reset or git reset --mixed will fill up our index or staging area with commit we specify. Now after we fill up our index or staging area with specific commit, we can generate all or specific files with git checkout -- \u0026lt;path\u0026gt;.\nHonestly the most interesting part is the git checkout part. With git checkout, we can do full dotfiles init or partial init. What i mean by partial init is that when we don\u0026rsquo;t need all the files on the new system, let\u0026rsquo;s say we only our vim config, we can just do git checkout -- ~/.vim and git will only generate the .vim directory with all of the files in it. The benefit of that, is we can put all our config in one git repository and still able to only generate the files we need rather than all the files in the git repository. To initialize all the files in our dotfiles repository, we can do git checkout -- ~.\nSo, to sum up the 3 important command for this to work is:\ngit --git-dir=\u0026#34;...\u0026#34; --work-tree=\u0026#34;...\u0026#34; init git --git-dir=\u0026#34;...\u0026#34; --work-tree=\u0026#34;...\u0026#34; reset git --git-dir=\u0026#34;...\u0026#34; --work-tree=\u0026#34;...\u0026#34; checkout -- \u0026lt;path\u0026gt; Alright, that\u0026rsquo;s it for this article. I will let you explore the implementation and the possibilities of this method yourself. See you next time!\nReferences  Romkatv\u0026rsquo;s bootstrap dotfiles  List of dotfiles manager .  "},{"ref":"https://bruhtus.github.io/posts/clean-up-untracked-file-in-git-repo/","title":"Clean Up Untracked File in Git Repo","section":"posts","tags":["Notes","Linux","Shell","Git"],"date":"2022.08.20","body":"Have you ever feels like deleting all the untracked file or directory in git repository is such a pain?\nIf you do, then this post might be for you!\nOk, first thing first, there is a git command clean which help us delete the untracked file. We can even use it with interactive interface. To invoke the interactive interface, we can use this command:\ngit clean -i . What that command does is prompt us an interactive interface with all the untracked file in current directory.\nTo make it start from the root of git repository, we can use this command:\ngit clean -i $(git rev-parse --show-toplevel) The git rev-parse --show-toplevel will get us the path of current git repository root. If you don\u0026rsquo;t know what i mean by git repository root, we can think of it as the directory or path that has .git directory.\nBut, the clean command has a downside. The clean command does not let us select specific file under untracked directory. It will only let us delete the entire untracked directory with all the file in it.\nTo get around this issue, we can make a shell alias like this:\nalias gurm=\u0026#39;git ls-files --others --exclude-standard | fzf --multi | xargs -r rm -v\u0026#39;  You can change gurm to anything you want.\n The dependencies from shell alias above are:\n git fzf xargs  git ls-files --others --exclude-standard will list all the untracked file and also exclude the file from .gitignore.\nfzf is a fuzzy finder to select the untracked file we want to remove, we also give flags --multi so that we can select multiple file with tab key.\nFinally, we execute rm command with xargs -r. What xargs -r do is make sure that we have some input from standard input (stdin), if there is no input from stdin, xargs will not execute the command. It is useful to prevent an error from a command that require an argument.\nAlright, that\u0026rsquo;s all. Have a nice day!\n"},{"ref":"https://bruhtus.github.io/posts/git-repo-backup/","title":"Git Repository Backup","section":"posts","tags":["Git"],"date":"2021.01.18","body":" Have you ever thought that some day your git remote repository service account got banned or even their server went down? It always crossed my mind and if that happen i would lose all my source code. So in this post i\u0026rsquo;m gonna explain how to backup your git repository locally and to other git remote repository services.\n Skip-able Part Git is a version control system for tracking any changes in any set of files. It\u0026rsquo;s basically a tool that makes tracking changes on your code easier, so you would know which line fix a certain bug and so on.\nThere\u0026rsquo;re a lot of git remote repository such as github, gitlab, bitbucket, codeberg and so on. The most popular one is github, but like other platform, github could decide whether to let you continue in their platform or banned you in their platform. You can check an article about github banned developer account on here and it seems like github in the process of restoring access to all developer in iran, you can check the github CEO tweet here .\nYou might be thinking \u0026ldquo;well, i\u0026rsquo;m not on those country so why should i worry about that?\u0026rdquo;. My point is not about the country that got banned, but about what would you do if your account got banned and all access to you code was gone. We can\u0026rsquo;t take anything for granted these days so better start backup your git repository rather than regret it later.\nBackup Git Repository First of all, there\u0026rsquo;re two ways you can backup a git repository that i knew. The first one is to backup locally in your machine, and the second one is to backup on multiple platforms or even on your own server.\nBackup Git Repository Locally There\u0026rsquo;re two ways to backup your git repository locally on your local machine, that is clone everything (basically the normal git clone command) and clone git bare.\nClone Everything in Git Repository You can backup every file in your git repository by doing the normal git clone \u0026lt;git-url.git\u0026gt; command. By doing that, you download every file in your repository with their actual size and you can do git workflow in it.\nIt\u0026rsquo;s basically the usual way to clone a git repository.\nClone Git Bare You can backup only the git bare from a git repository. To make it simpler, git bare is a .git directory when you initialize a directory as a git repository using git init command.\nSo if you clone the git bare instead of the full git repository, you can get all commit history and all the branch on your git repository without actually downloading all your file so the git bare size is quite small.\nYou might ask \u0026ldquo;if you didn\u0026rsquo;t download all your file then how you called that a backup?\u0026rdquo;. Ok so here\u0026rsquo;s the thing, by cloning a git bare you backup all your commit history and if you decide to upload your git repository to another git services or even your own server, you just need to push those git bare backup and git gonna create all your file with all the commit history on the new git repository. So basically you have your git repository backup without taking too much space on your local storage.\nSo, how can you backup using git bare clone? git have a backup mechanism but it\u0026rsquo;s not obvious, git has a --mirror flag that you can use to backup or push a git bare repository.\nFirst, you need to clone a git bare from git repository by doing\ngit clone --bare \u0026lt;git-repo-url.git\u0026gt; or\ngit clone --mirror \u0026lt;git-repo-url.git\u0026gt;  Both of the commands are basically the same, you can push using --mirror flag or add git remote repository and then push using the usual command. How to push with git bare repository is later in this post.\n Here\u0026rsquo;s an example, if i want to clone my instasaver git bare then the command i need is\ngit clone --bare https://github.com/bruhtus/instasaver.git or\ngit clone --mirror https://github.com/bruhtus/instasaver.git and then it\u0026rsquo;s gonna make instasaver.git directory where it stores all the commit history and branch.\nIf your git repository contains Git Large File Storage (LFS) objects then you need to download those git LFS objects too. First, you clone git bare with one of the command above (--mirror flag or --bare flag) and then download git LFS object with this command\ngit lfs fetch --all  Don\u0026rsquo;t forget to change directory (cd) into your git bare directory before applying those command.\n Backup Git Repository on Multiple Platforms There\u0026rsquo;re two ways you can backup your git repository on multiple platforms. First, you can use git remote add command, and second, you can push git bare repository into another git services. Uploading into your own server is beyond the scope of this post, so i\u0026rsquo;m not gonna explain about that here.\nAdd Git Remote Repository With git remote add you can add another platform so that you can also push into that platform.\nFor example, your main git repository service is github so you usually do\ngit remote add origin \u0026lt;github-repo-url.git\u0026gt; in your local git repository. That command is basically assign origin as your github repository, so if you want to push into your github repository you need to do\ngit push origin \u0026lt;branch\u0026gt; if you didn\u0026rsquo;t like origin as your github repository alias, you can change it to whatever you want, you can change it into github or even anu but you also need to change your git push command like this\ngit push github \u0026lt;branch\u0026gt; or\ngit push anu \u0026lt;branch\u0026gt; So if you want to add another platform and you have your full git working directory (not git bare version), you just need too assign another git repository service url.\nFor example, i want to add instasaver to gitlab. I just need to do\ngit remote add gitlab https://gitlab.com/bruhtus/instasaver.git and then if i want to push the changes to master branch, i just need to do\ngit push gitlab master other git workflow such as git add and git commit is the same.\n Don\u0026rsquo;t forget to change directory (cd) into your local git repo directory.\n Push Git Bare If you alreaady backup your git bare repository on your local machine, then all you gotta do is change directory (cd) into your git-bare-repo.git directory and then do\ngit push --mirror \u0026lt;new-git-repo-url.git\u0026gt; or you could also do\ngit remote add \u0026lt;platform\u0026gt; \u0026lt;new-git-repo-url.git\u0026gt; git push \u0026lt;platform\u0026gt; \u0026lt;branch\u0026gt;  You can change \u0026lt;platform\u0026gt; name to whatever you want such as anu or nganu, you do you.\n The difference between both command is that you can get all the branch if you use git push --mirror meanwhile you only get main branch if you use the usual git push command (without --mirror flag). So if you want to backup all the branch then you should probably use git push --mirror.\nThe disadvantage of using git bare is that you cannot use git workflow such as git add or git commit, you can only use git push command. If you want to update your git bare repository, you can do\ngit remote update inside your git bare directory.\nIf you have Git Large File Storage (LFS) objects, you need to push git LFS object separately using this command\ngit lfs push --all \u0026lt;new-git-repo-url.git\u0026gt; after you download all git LFS objects using git lfs fetch --all command.\nThe Conclusion  Do this post really need a conclusion? well, whatever, here we go.\n There\u0026rsquo;s no harm in backing up your git repository whether locally or on multiple platform, we can\u0026rsquo;t be so sure that some platform gonna stay the same. Maybe the platform we use gonna become worse and mindlessly banned a lot of account, who knows. So it\u0026rsquo;s better to start backup your git repository from now on before something like that happen.\nReferences  How to backup a git repository . How to mirror an entire existing git repository . Duplicating a repository . The difference between git clone \u0026ndash;mirror and git clone \u0026ndash;bare .  "}]