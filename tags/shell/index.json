[{"ref":"https://bruhtus.github.io/posts/pyv/","title":"Pyv: Minimalist Python Venv Management Tool","section":"posts","tags":["Shell","Python"],"date":"2021.04.16","body":" This is a continuation from my previous post (you can check it here ). Long story short, this is a minimalist way to manage your python virtual environment. All you need is python and git.\n What Is Pyv? Here\u0026rsquo;s a brief intro to what is pyv:\n Pyv is a simple shell function that let you manage python virtual environment that decoupled from project directory.\n To put it simply, pyv move the virtual environment to $PYV_dir which by default is $HOME/.cache/pyv\nHow Pyv Manage Virtual Environment Pyv can create, remove, activate, deactivate, and list python virtual environment. Below is the explanation for each action that pyv can do.\nCreate Virtual Environment Pyv create python virtual environment using python default command python -m venv to $PYV_DIR/{given-name}. The given-name can be from git repo name or user input.\nIf the user give pyv command an argument then pyv gonna create python virtual environment with that argument name. For example:\npce something-big With the command above, pyv gonna create python virtual environment with the name something-big. pce is pyv command to to create python virtual environment (why would i made something with long command?).\nPyv also can create python virtual environment with git repo name. If you give no argument and just enter pce in a working git repo then pyv gonna create python virtual environment using the git repo name.\n\u0026ldquo;How does pyv do that?\u0026rdquo; you might ask, well, pyv use the command git rev-parse --show-toplevel to get the git root directory name (with a lot of trimming of course). For those who don\u0026rsquo;t know what git root directory, to make simple, git root directory is the directory where you first use git init command or the directory that have .git directory.\nPlease do remember tho, you can only use pce without any argument in git working directory and not in git bare directory. What i mean by git working directory is the normal git repo that has .git directory in it.\nHere\u0026rsquo;s an example of pce without an argument (in case you\u0026rsquo;re still confused):\npce Yup, only that. Simple right?\nRemove Virtual Environment After creating virtual environment, how do you delete the virtual environment?\nYou can remove the virtual environment using pre command with or without argument similar to creating virtual environment.\nFor example, we already create something-big python virtual environment. And now we want to remove those virtual environment. All we need to do is something like this:\npre something-big Those command gonna invoke the rm command to remove something-big virtual environment directory in $PYV_DIR. So the pre command depends on how you setup your rm command in your shell.\nIf you create virtual environment using the git repo name, and you want to remove those environment, you can use pre without an argument inside those git repo directory (assumming you haven\u0026rsquo;t changed the directory name). How to use the command is the same as when you create the virtual environment, just type\npre and you\u0026rsquo;re done.\nActivate Virtual Environment Ok, now you know how to create and remove the virtual environment using pyv. Now, how do you activate those virtual environment?\nBecause we use default python python -m venv command, we need to know how the activate the virtual environment created using those command.\nAccording to python venv documentation , we need to source the activate file in \u0026lt;venv-dir\u0026gt;/bin/activate.\n Did you know that the activate file is also a shell function? Now you know.\n So, the pyv command to activate the virtual environment is pae. Similar to previous command, you can use pae with or without an argument. pae command basically to source activate file in virtual environment directory that located in $PYV_DIR.\nLike previous command, let\u0026rsquo;s say we have something-big virtual env and we want to activate those command. All we need to do is\npae something-big or if you create a virtual environment using git repo name (assuming you didn\u0026rsquo;t change the git repo directory name), then you can just use\npae without any argument.\nDeactivate Virtual Environment After you know how to create, remove, and activate virtual environment with pyv. Now it\u0026rsquo;s time for you to know how to deactivate virtual environment.\nYou can deactivate the virtual environment either using default deactivate command or using pde. pde is just an alias for deactivate command provided by python venv. You do you.\nPlease keep in mind that you don\u0026rsquo;t need any argument to deactivate virtual environment.\nList Virtual Environment The last thing is how to list all the virtual environment that available?\nTo list all the virtual environment that ever created, you can use pve command without an argument or ls -l $PYV_DIR. pve is just an alias for ls -l $PYV_DIR.\nConclusions There\u0026rsquo;s always an upside/downside to a project, and this project is no exception.\nThe upside is that, it\u0026rsquo;s minimal. If you didn\u0026rsquo;t do anything fancy with your python virtual environment then pyv probably gonna fit your need.\nThe downside is also \u0026ldquo;it\u0026rsquo;s minimal\u0026rdquo;. If you use default options that come with default python venv command, then you can\u0026rsquo;t do that with pyv. Pyv only able to handle python -m venv \u0026lt;env-directory\u0026gt;. That\u0026rsquo;s all.\n At the time of writing this article, i\u0026rsquo;ve only tested pyv in bash and zsh. I might provide support for fish, csh/tcsh in the future.\n References  A few alternative to manage python virtual environment . Python venv documentation .  "},{"ref":"https://bruhtus.github.io/posts/python-vs-shell/","title":"Python Script vs. Shell Script: Command Line Use Case","section":"posts","tags":["Linux","Python","Shell"],"date":"2021.01.14","body":" In this post i\u0026rsquo;m comparing performance python script and shell script that i\u0026rsquo;ve made. The script objective is to check git status on every git repo directory.\n Skip-able Part  Just a background story why i made this post\n Have you wondered what performance between python script and shell script (or some people might say bash script) to run command on terminal? no? same, just kidding. I\u0026rsquo;m curious about shell script because i can do command line stuff with python script too which for my past self is easier to read.\nFor around a month, i\u0026rsquo;ve learned shell scripting from youtube (mostly luke smith videos ) and i gotta say that for command line use case, shell script is more efficient than python script. Please keep in mind that i\u0026rsquo;m not an expert when it comes to python scripting or shell scripting, so there might be some performance enhancement that you can make to my script.\nA Brief Intro to Shell Script You might be wondering \u0026ldquo;what is shell script?\u0026rdquo; well, to put it simpler, it\u0026rsquo;s a script that you can run with shell. Shell, like python, is a programming language and that\u0026rsquo;s why you can run for loop in a terminal like a psychopath, just kidding i did that sometimes (maybe i\u0026rsquo;m a pyschopath? ðŸ‘€).\nThere are quite a few ways to run shell script, here\u0026rsquo;s some that i know:\n  Make script executable by doing chmod +x \u0026lt;script-name\u0026gt; and then run the script by doing ./\u0026lt;script-name\u0026gt; if you\u0026rsquo;re already in the same directory as the script or chmod +x \u0026lt;path-to-script\u0026gt;/\u0026lt;script-name\u0026gt; and then run the script by doing \u0026lt;path-to-script\u0026gt;/\u0026lt;script-name\u0026gt; if you\u0026rsquo;re not in the same directory as the script. For example: If i want to run my git-status-checker script, then what i would do is type chmod +x git-status-checker if i already in the same directory as git-status-checker script and then run the script by typing ./git-status-checker. But, if i\u0026rsquo;m not in the same directory as git-status-checker, let\u0026rsquo;s say i\u0026rsquo;m in Download directory meanwhile the script is in Script directory, then what i would do is type chmod +x ~/script/git-status-checker and then run the script by typing ~/script/git-status-checker.\n  Using sh or bash command. For example: If i want to run my git-status-checker script, then i run the script by typing sh git-status-checker or bash git-status-checker, both command basically do the same thing.\n  The Test In this post, i\u0026rsquo;m gonna test the runtime both python script and shell script that i\u0026rsquo;ve made. The script objective is to check git status in each git repo directory on my machine.\nThe Environment of The Test All my git repo directory is located in all_git directory on home directory, so i only need to focus on that directory which is gonna make the task of the script a little bit easier and faster than check all other directory too.\nThe amount of not staged for commit is the same when running both script, which is around 13 in total. So the performance may decrease as the amount of unstaged increase.\nI\u0026rsquo;m gonna run the in two way, the first test is including git status for git submodules and the second test is excluding git status for git submodules.\nThe Results First Test In the first test, the runtime of python script is around 0.08 - 0.12 seconds and the runtime of shell script is around 0.07 - 0.08 seconds. Here\u0026rsquo;s the example of runtime of both script (which at this time coincidentally the same):\nSecond Test In the second test, the runtime of python script is around 0.05 - 0.07 seconds and the runtime of shell script is around 0.01 - 0.02 seconds. Here\u0026rsquo;s the example of runtime of both script:\nThe Explanation The effect of checking git status in git submodules is quite a lot but still less than a second which gonna make people think \u0026ldquo;it\u0026rsquo;s not that much of a difference\u0026rdquo;, well, in case you forgot that this script objective is just to check git status on each git repo directory, it\u0026rsquo;s just a simple task. If you\u0026rsquo;re going to make a more complicated task with a lot of command, that\u0026rsquo;s where you\u0026rsquo;re gonna see the gap.\nI\u0026rsquo;m gonna explain the first test source code first, below is the python script for the first test:\nimport os home = \u0026#39;/home/bruhtus/\u0026#39; dir_list = [dirname for dirname in os.listdir(f\u0026#39;{home}/all_git\u0026#39;) if os.path.isdir(f\u0026#39;{home}/all_git/{dirname}\u0026#39;) == True] for dirname in dir_list: path = f\u0026#39;{home}/all_git/{dirname}\u0026#39; os.system(f\u0026#39;echo {path}\u0026#39;) if os.path.exists(f\u0026#39;{path}/.gitmodules\u0026#39;) == True: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) os.system(f\u0026#39;git -C {path}submodule foreach git status -s\u0026#39;) else: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) And below is the shell script for the first test:\n#!/bin/sh  for d in $(ls -d ~/all_git/*/); do echo $d \u0026amp;\u0026amp; git -C $d status -s \u0026amp;\u0026amp; ls -a $d | grep -q .gitmodules \u0026amp;\u0026amp; git -C $d submodule foreach git status -s done Let\u0026rsquo;s take step by step of the processes. The first process is to list all directory in all_git directory, because we already specify that all git repo directory gonna be in all_git directory so we don\u0026rsquo;t need to check if it\u0026rsquo;s a git repo or not (one less task). So, here\u0026rsquo;s a comparison of the python script and shell script:\nThe python part below:\nhome = \u0026#39;/home/bruhtus/\u0026#39; dir_list = [dirname for dirname in os.listdir(f\u0026#39;{home}/all_git\u0026#39;) if os.path.isdir(f\u0026#39;{home}/all_git/{dirname}\u0026#39;) == True] for dirname in dir_list: is equivalent to this part in shell script:\nfor d in $(ls -d ~/all_git/*/); do Both of the script take list of directory in all_git directory and do a for loop to check each folder. You might be able to optimize my python script but i think that the shell script is much simpler than python script. What i mean simpler is less lines of code, not easier to understand. If you need an easier to understand code then python is the way, but it\u0026rsquo;s not really the topic of this post (everyone knows that python script is human readable, right?).\nLet\u0026rsquo;s continue, in the python part below:\npath = f\u0026#39;{home}/all_git/{dirname}\u0026#39; os.system(f\u0026#39;echo {path}\u0026#39;) if os.path.exists(f\u0026#39;{path}/.gitmodules\u0026#39;) == True: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) os.system(f\u0026#39;git -C {path}submodule foreach git status -s\u0026#39;) else: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) is equivalent to this part in shell script:\necho $d \u0026amp;\u0026amp; git -C $d status -s \u0026amp;\u0026amp; ls -a $d | grep -q .gitmodules \u0026amp;\u0026amp; git -C $d submodule foreach git status -s done That second process is to check the git status and git submodules status of all directories. The part where there\u0026rsquo;s echo is basically print out anything that we give, in this case it\u0026rsquo;s gonna print directory name so i\u0026rsquo;m not gonna go into detail for that part.\nNow i\u0026rsquo;m gonna explain a little bit about \u0026amp;\u0026amp; command in shell, it\u0026rsquo;s basically let you run the second command (on the right side) if the first command (on the left side) success. So, it\u0026rsquo;s basically an equivalent of if-else statement in most programming language. The shell script part below:\ngit -C $d status -s \u0026amp;\u0026amp; ls -a $d | grep -q .gitmodules \u0026amp;\u0026amp; git -C $d submodule foreach git status -s is equivalent to this part of python script:\nif os.path.exists(f\u0026#39;{path}/.gitmodules\u0026#39;) == True: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) os.system(f\u0026#39;git -C {path}submodule foreach git status -s\u0026#39;) else: os.system(f\u0026#39;git -C {path}status -s\u0026#39;) The ls -a $d | grep -q .gitmodules is equivalent to if os.path.exists(f'{path}/.gitmodules') == True, both command check if there\u0026rsquo;s a git submodules in the git repo directory or not. So in the second test, i\u0026rsquo;m removing those if-else statement and then run only git status which makes shell script faster than python script.\nThe Conclusion For command line interface stuff, you should probably use shell script instead of python script. I\u0026rsquo;m not saying that python is bad, it\u0026rsquo;s just not the right tool for command line interface stuff. Yeah python can do almost everything but that doesn\u0026rsquo;t mean python is the best at everything, at least not at command line interface use case which is shell script clearly better here.\nReferences  Luke smith youtube channel . Distrotube youtube channel . Git command without change directory . Git submodule documentation .  "},{"ref":"https://bruhtus.github.io/posts/zsh-aliases/","title":"Zsh Aliases: Be Lazy!","section":"posts","tags":["Linux","Shell"],"date":"2020.12.13","body":" Have you ever thought that typing a long command is such a pain? well, here\u0026rsquo;s one of the solution for you.\n Skip-able Part  Just a background story why i write this in the first place.\n At some random time back then i thought \u0026ldquo;can i increase my speed while using the command line interface?\u0026rdquo; and there\u0026rsquo;s two option i could think of back then, the first one is to increase my typing speed and the second one is to make everything i type shorter.\nHonestly i like to take it easy when typing, i\u0026rsquo;m not really those rush type who are trying to type fast. I don\u0026rsquo;t really care about the speed of my typing as long as i\u0026rsquo;m comfortable typing at that speed. It\u0026rsquo;s more like durability rather than speed and that\u0026rsquo;s why i take it easy. So, increasing my typing speed is a no (at least for me).\nThe second option is where piques my interest. From that point i did some research how i can shorten the command i use on internet (google, youtube, and even pornhub but unfortunately no one uploaded on pornhub yet (maybe i should be the one to upload on pornhub? hmm)).\nA Brief Intro to Shell Alias Basically shell alias is a key shortcut for the command that you want to use. Here\u0026rsquo;s an example: If you want to make a new directory, let\u0026rsquo;s say the name of the directory is \u0026ldquo;anu\u0026rdquo;, then if the directory already exist, you want the command doesn\u0026rsquo;t give an error message as a feedback. So here\u0026rsquo;s the command: mkdir -p anu. Everytime you want to make a new directory without an error message if the directory already exist, you need to type mkdir -p \u0026lt;directory-name\u0026gt; and further more if there\u0026rsquo;s a typo while you type it, uh that\u0026rsquo;s such a pain.\nSo, how would you make that simpler? well by using shell alias of course, and in this post i\u0026rsquo;m gonna use Z shell or zsh so the syntax might be different from bash and fish shell. Please keep that in mind.\nType of Zsh Aliases Before we start to how to make a shell aliases or in particular zsh aliases, we need to type the type of aliases that zsh has.\nThere\u0026rsquo;re four type of zsh aliases:\n Simple aliases Suffix aliases Function aliases Global aliases  Simple Aliases Like the name suggest, it\u0026rsquo;s just a simple stuff (or you could say the default?). Here\u0026rsquo;s an example of simple alias: alias md='mkdir -p' From above example, if you want to make a new directory without error message if the directory already exist then you only need to type md rather than mkdir -p. So, it\u0026rsquo;s basically telling the terminal that md equivalent to command mkdir -p and execute mkdir -p command immediately.\nSuffix Aliases Suffix alias is for opening a specific extension in a specific program, it defined using -s flag. Here\u0026rsquo;s an example of suffix alias: alias -s py=vim From above example, it\u0026rsquo;s basically telling the terminal to open every extension .py in vim. So if you have a python file, let\u0026rsquo;s say anu.py, then you just need to type anu.py and it\u0026rsquo;s gonna translate to vim anu.py, opening anu.py file in vim.\nPersonally i don\u0026rsquo;t really use this alias because i like to type vim and even if you\u0026rsquo;re too lazy to type vim you could use simple alias instead, like alias v='vim'.\nFunction Aliases Function alias is when you want an input in your command. For example, you want to open a python file and then preview the output using less (you use try it yourself, i won\u0026rsquo;t explain it). Here\u0026rsquo;s the function alias for that scenario: function anu(){ python $@ | less} #the @ symbol is basically saying to take everything after the command as input. So everytime you run a python script with anu then it\u0026rsquo;s output gonna be displayed in less. Let\u0026rsquo;s say you want to open itu.py, then you use anu itu.py and you\u0026rsquo;re gonna see the output inside of less rather than on terminal.\nHere\u0026rsquo;s another example: function nganu(){ python -c $1} #the 1 number is saying to take the first argument as an input, you could add another input by using $2, $3, and so on. If you type nganu 'import numpy as np' in your terminal then you\u0026rsquo;re gonna execute python -c 'import numpy as np'. So it\u0026rsquo;s basically take the first argument which is 'import numpy as np' as an input (please keep in mind that using '' considered as one argument).\nGlobal Aliases Global alias is the command that you could place anywhere in the sequences. For example, you want to grep a specific file in your directory and you probably gonna type ls | grep filename (honestly i don\u0026rsquo;t care what you type, you do you), if you type ls | grep filename every time you want to search for something than it\u0026rsquo;s gonna become a hassle.\nSo, what should you do? well, you could give a global alias to grep like this: alias -g G='| grep'. After that you could place G in the middle of your command, like this: ls G filename | less (it\u0026rsquo;s gonna direct the grep result to less) or in the back of your command, like this: ls G filename (not using less). The G alias is only for | grep command so you still need to type the pattern to search or in this case a filename.\nTips To make some Aliases First, before you make aliases, please check if the command already exist or not using which command. For example: i want to name my alias ls, before i make alias ls, i\u0026rsquo;m need to type which ls to show me if ls already assigned to other program or command. If after you type which \u0026lt;alias-you-want\u0026gt; and there\u0026rsquo;s an error like \u0026lt;alias-you-want\u0026gt; not found then you\u0026rsquo;re ready to go.\nSecond, don\u0026rsquo;t make to much specific simple aliases. For example, you want to make alias to install packages from your package manager, let\u0026rsquo;s say debian package manager (apt), you need to type sudo apt install \u0026lt;package-name\u0026gt;, and you want to make it simple by using alias like alias sai='sudo apt install'. So everytime you want to install something you just need to type sai \u0026lt;package-name\u0026gt;, simple right? well, honestly it\u0026rsquo;s not really a good practice because over time you\u0026rsquo;re gonna forget what the command behind those alias. If you\u0026rsquo;re really forgot what the command then there\u0026rsquo;s which command as a livesaver, but do you really want that? Imagine you\u0026rsquo;re using another machine without your aliases, then you forgot a simple command because you\u0026rsquo;re using to much alias, isn\u0026rsquo;t that kind of sad?\nConclusion Shell alias is like a double edge sword, use it carefully and don\u0026rsquo;t be dependent on it. If possible, only make aliases if you\u0026rsquo;re using it a lot and already know the basic or maybe make aliases that represent the executed command.\nBonus Useful Alias function sd(){cd \u0026quot;$(du ~ | awk '{print $2}' | fzf)\u0026quot;}  That\u0026rsquo;s my first attempt using fzf, it basically change directory using fzf output as an input.\n function cs(){find ~ -type f | fzf | xargs -o -r vim}  That\u0026rsquo;s basically find every files in home directory using find and fzf and then open the file in vim directly (the parameter -o for not broke my terminal after the command (for some reason) and the -r for if there\u0026rsquo;s no input then it\u0026rsquo;s gonna back to terminal instead opening vim. For more detail please check on man page).\n References  Types of zsh aliases . Luke smith youtube channel . Distrotube youtube channel .  "}]